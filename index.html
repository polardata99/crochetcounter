<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>–°—á—ë—Ç—á–∏–∫ –≤—è–∑–∞–Ω–∏—è –∫—Ä—é—á–∫–æ–º</title>
    <script crossorigin src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
    <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        body {
            margin: 0;
            padding: 0;
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', 'Roboto', 'Oxygen', 'Ubuntu', 'Cantarell', 'Fira Sans', 'Droid Sans', 'Helvetica Neue', sans-serif;
            -webkit-font-smoothing: antialiased;
            -moz-osx-font-smoothing: grayscale;
        }
        
        input, textarea, select {
            font-size: 16px !important;
        }
    </style>
</head>
<body>
    <div id="root"></div>

    <script type="text/babel">
        const { useState, useEffect, useRef, useCallback } = React;

        // SVG Icons
        const Plus = ({ className = "w-6 h-6" }) => (
            <svg className={className} xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2">
                <line x1="12" y1="5" x2="12" y2="19"/><line x1="5" y1="12" x2="19" y2="12"/>
            </svg>
        );
        const Minus = ({ className = "w-6 h-6" }) => (
            <svg className={className} xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2">
                <line x1="5" y1="12" x2="19" y2="12"/>
            </svg>
        );
        const Play = ({ className = "w-6 h-6" }) => (
            <svg className={className} xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2">
                <polygon points="5 3 19 12 5 21 5 3"/>
            </svg>
        );
        const Pause = ({ className = "w-6 h-6" }) => (
            <svg className={className} xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2">
                <rect x="6" y="4" width="4" height="16"/><rect x="14" y="4" width="4" height="16"/>
            </svg>
        );
        const RotateCcw = ({ className = "w-6 h-6" }) => (
            <svg className={className} xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2">
                <polyline points="1 4 1 10 7 10"/><path d="M3.51 15a9 9 0 1 0 2.13-9.36L1 10"/>
            </svg>
        );
        const Edit3 = ({ className = "w-6 h-6" }) => (
            <svg className={className} xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2">
                <path d="M12 20h9"/><path d="M16.5 3.5a2.121 2.121 0 0 1 3 3L7 19l-4 1 1-4L16.5 3.5z"/>
            </svg>
        );
        const Trash2 = ({ className = "w-6 h-6" }) => (
            <svg className={className} xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2">
                <polyline points="3 6 5 6 21 6"/><path d="M19 6v14a2 2 0 0 1-2 2H7a2 2 0 0 1-2-2V6m3 0V4a2 2 0 0 1 2-2h4a2 2 0 0 1 2 2v2"/>
                <line x1="10" y1="11" x2="10" y2="17"/><line x1="14" y1="11" x2="14" y2="17"/>
            </svg>
        );
        const ChevronRight = ({ className = "w-5 h-5" }) => (
            <svg className={className} xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2">
                <polyline points="9 18 15 12 9 6"/>
            </svg>
        );
        const Mic = ({ className = "w-6 h-6" }) => (
            <svg className={className} xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2">
                <path d="M12 1a3 3 0 0 0-3 3v8a3 3 0 0 0 6 0V4a3 3 0 0 0-3-3z"/><path d="M19 10v2a7 7 0 0 1-14 0v-2"/><line x1="12" y1="19" x2="12" y2="23"/><line x1="8" y1="23" x2="16" y2="23"/>
            </svg>
        );
        const Volume2 = ({ className = "w-6 h-6" }) => (
            <svg className={className} xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2">
                <polygon points="11 5 6 9 2 9 2 15 6 15 11 19 11 5"/><path d="M19.07 4.93a10 10 0 0 1 0 14.14M15.54 8.46a5 5 0 0 1 0 7.07"/>
            </svg>
        );
        const VolumeX = ({ className = "w-6 h-6" }) => (
            <svg className={className} xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2">
                <polygon points="11 5 6 9 2 9 2 15 6 15 11 19 11 5"/><line x1="23" y1="9" x2="17" y2="15"/><line x1="17" y1="9" x2="23" y2="15"/>
            </svg>
        );

        const CrochetCounter = () => {
            const [mode, setMode] = useState('setup');
            const [rows, setRows] = useState([]);
            const [currentRow, setCurrentRow] = useState(0);
            const [currentElement, setCurrentElement] = useState(0);
            const [isPaused, setIsPaused] = useState(false);
            const [history, setHistory] = useState([]);
            const [currentRowPattern, setCurrentRowPattern] = useState([]);
            const [customInput, setCustomInput] = useState('');
            const [repeatCount, setRepeatCount] = useState(1);
            const [customStitches, setCustomStitches] = useState(1);
            const [customBalance, setCustomBalance] = useState(0);
            const [currentRowNumber, setCurrentRowNumber] = useState(1);
            const [manualInitialStitches, setManualInitialStitches] = useState('');
            const [isListening, setIsListening] = useState(false);
            const [recognition, setRecognition] = useState(null);
            const [lastCommandTime, setLastCommandTime] = useState(0);
            const [colorInput, setColorInput] = useState('');
            const [repeatRowIndex, setRepeatRowIndex] = useState(null);
            const [repeatRowCount, setRepeatRowCount] = useState(1);
            const [voiceFeedback, setVoiceFeedback] = useState(false);
            const [elementModalOpen, setElementModalOpen] = useState(false);
            const [selectedElement, setSelectedElement] = useState(null);
            const [elementRepeatCount, setElementRepeatCount] = useState(1);
            const [isEditingRow, setIsEditingRow] = useState(false);
            const [editingRowNumber, setEditingRowNumber] = useState(null);
            const [editingElementIndex, setEditingElementIndex] = useState(null);
            
            // Scheme states
            const [schemeMode, setSchemeMode] = useState('main');
            const [availableSchemes, setAvailableSchemes] = useState([]);
            const [currentScheme, setCurrentScheme] = useState(null);
            const [currentSchemeId, setCurrentSchemeId] = useState('manual'); // 'manual' –∏–ª–∏ id —Å—Ö–µ–º—ã
            const [schemeProgress, setSchemeProgress] = useState({});
            const [currentPartIndex, setCurrentPartIndex] = useState(null);
            const [currentInstanceIndex, setCurrentInstanceIndex] = useState(0);
            
            // Create scheme states
            const [newSchemeName, setNewSchemeName] = useState('');
            const [newSchemeEmoji, setNewSchemeEmoji] = useState('');
            const [newSchemeDifficulty, setNewSchemeDifficulty] = useState('–°—Ä–µ–¥–Ω–∏–π');
            const [schemeParts, setSchemeParts] = useState([]);
            const [currentPartName, setCurrentPartName] = useState('');
            const [currentPartQuantity, setCurrentPartQuantity] = useState(1);
            const [editingPartIndex, setEditingPartIndex] = useState(null);
            
            // Edit scheme state
            const [editingScheme, setEditingScheme] = useState(null);
            
            // Refs to track current values for voice recognition
            const isListeningRef = useRef(isListening);
            const currentRowRef = useRef(currentRow);
            const currentElementRef = useRef(currentElement);
            const historyRef = useRef(history);
            const rowsRef = useRef(rows);
            const modeRef = useRef(mode);
            const isPausedRef = useRef(isPaused);
            
            useEffect(() => { isListeningRef.current = isListening; }, [isListening]);
            useEffect(() => { currentRowRef.current = currentRow; }, [currentRow]);
            useEffect(() => { currentElementRef.current = currentElement; }, [currentElement]);
            useEffect(() => { historyRef.current = history; }, [history]);
            useEffect(() => { rowsRef.current = rows; }, [rows]);
            useEffect(() => { modeRef.current = mode; }, [mode]);
            useEffect(() => { isPausedRef.current = isPaused; }, [isPaused]);
            
            // Auto-save rows when they change (debounced)
            useEffect(() => {
                if (currentSchemeId) {
                    // –ù–µ–±–æ–ª—å—à–∞—è –∑–∞–¥–µ—Ä–∂–∫–∞ —á—Ç–æ–±—ã state —Ç–æ—á–Ω–æ –æ–±–Ω–æ–≤–∏–ª—Å—è
                    const timer = setTimeout(() => {
                        saveRowsForScheme(currentSchemeId, rows);
                        console.log('üíæ Saved rows for', currentSchemeId, ':', rows.length, 'rows');
                    }, 100);
                    return () => clearTimeout(timer);
                }
            }, [rows, currentSchemeId]);
            
            // Load manual rows on initial mount
            useEffect(() => {
                const savedRows = loadRowsForScheme('manual');
                if (savedRows.length > 0) {
                    setRows(savedRows);
                }
            }, []);

            const quickButtons = [
                { label: '–°–ë–ù', value: '—Å–±–Ω', color: 'bg-blue-100 hover:bg-blue-200 text-blue-700' },
                { label: '–°–°–ù', value: '—Å—Å–Ω', color: 'bg-purple-100 hover:bg-purple-200 text-purple-700' },
                { label: '–í–ü', value: '–≤–ø', color: 'bg-yellow-100 hover:bg-yellow-200 text-yellow-700' },
            ];
            
            // Voice-triggered version that uses refs
            const handleVoiceCommand = useCallback(() => {
                const currentPattern = rowsRef.current[currentRowRef.current]?.pattern;
                if (!currentPattern) return;
                
                const currentElementData = currentPattern[currentElementRef.current];
                if (!currentElementData) return;
                
                setHistory([...historyRef.current, currentElementData]);
                
                if (currentElementRef.current < currentPattern.length - 1) {
                    setCurrentElement(currentElementRef.current + 1);
                    
                    // –û–∑–≤—É—á–∫–∞ —Å–ª–µ–¥—É—é—â–µ–≥–æ —ç–ª–µ–º–µ–Ω—Ç–∞
                    if (voiceFeedback) {
                        const nextElement = currentPattern[currentElementRef.current + 1];
                        
                        if (nextElement.type === 'COLOR_CHANGE') {
                            speak('–°–º–µ–Ω–∏ —Ü–≤–µ—Ç –Ω–∞ ' + nextElement.color);
                        } else if (nextElement.stitches > 1) {
                            speak(nextElement.type + ', ' + nextElement.stitches + ' –ø—Ä–æ–≤—è–∑–æ–≤');
                        } else {
                            speak(nextElement.type);
                        }
                    }
                } else {
                    if (currentRowRef.current < rowsRef.current.length - 1) {
                        setCurrentRow(currentRowRef.current + 1);
                        setCurrentElement(0);
                        setHistory([]);
                        
                        // –û–∑–≤—É—á–∫–∞ –Ω–æ–≤–æ–≥–æ —Ä—è–¥–∞
                        if (voiceFeedback) {
                            const nextRow = rowsRef.current[currentRowRef.current + 1].pattern;
                            const firstElement = nextRow[0];
                            const nextRowNumber = rowsRef.current[currentRowRef.current + 1].rowNumber;
                            
                            if (firstElement.type === 'COLOR_CHANGE') {
                                speak('–†—è–¥ ' + nextRowNumber + '. –°–º–µ–Ω–∏ —Ü–≤–µ—Ç –Ω–∞ ' + firstElement.color);
                            } else if (firstElement.stitches > 1) {
                                speak('–†—è–¥ ' + nextRowNumber + '. ' + firstElement.type + ', ' + firstElement.stitches + ' –ø—Ä–æ–≤—è–∑–æ–≤');
                            } else {
                                speak('–†—è–¥ ' + nextRowNumber + '. ' + firstElement.type);
                            }
                        }
                    } else {
                        alert('üéâ –ü–æ–∑–¥—Ä–∞–≤–ª—è—é! –¢—ã –∑–∞–≤–µ—Ä—à–∏–ª–∞ –≤—Å–µ —Ä—è–¥—ã!');
                        setMode('setup');
                    }
                }
            }, [voiceFeedback]);
            
            // Voice-triggered undo
            const handleVoiceUndo = useCallback(() => {
                if (currentElementRef.current > 0) {
                    const prevElement = rowsRef.current[currentRowRef.current].pattern[currentElementRef.current - 1];
                    setCurrentElement(currentElementRef.current - 1);
                    setHistory(historyRef.current.slice(0, -1));
                    
                    if (voiceFeedback) {
                        if (prevElement.type === 'COLOR_CHANGE') {
                            speak('–ù–∞–∑–∞–¥. –°–º–µ–Ω–∏ —Ü–≤–µ—Ç –Ω–∞ ' + prevElement.color);
                        } else if (prevElement.stitches > 1) {
                            speak('–ù–∞–∑–∞–¥. ' + prevElement.type + ', ' + prevElement.stitches + ' –ø—Ä–æ–≤—è–∑–æ–≤');
                        } else {
                            speak('–ù–∞–∑–∞–¥. ' + prevElement.type);
                        }
                    }
                } else if (currentRowRef.current > 0) {
                    const prevRow = rowsRef.current[currentRowRef.current - 1].pattern;
                    const lastElement = prevRow[prevRow.length - 1];
                    setCurrentRow(currentRowRef.current - 1);
                    setCurrentElement(prevRow.length - 1);
                    setHistory(prevRow.slice(0, -1));
                    
                    if (voiceFeedback) {
                        const prevRowNumber = rowsRef.current[currentRowRef.current - 1].rowNumber;
                        
                        if (lastElement.type === 'COLOR_CHANGE') {
                            speak('–ù–∞–∑–∞–¥ –≤ —Ä—è–¥ ' + prevRowNumber + '. –°–º–µ–Ω–∏ —Ü–≤–µ—Ç –Ω–∞ ' + lastElement.color);
                        } else if (lastElement.stitches > 1) {
                            speak('–ù–∞–∑–∞–¥ –≤ —Ä—è–¥ ' + prevRowNumber + '. ' + lastElement.type + ', ' + lastElement.stitches + ' –ø—Ä–æ–≤—è–∑–æ–≤');
                        } else {
                            speak('–ù–∞–∑–∞–¥ –≤ —Ä—è–¥ ' + prevRowNumber + '. ' + lastElement.type);
                        }
                    }
                }
            }, [voiceFeedback]);
            
            // Text-to-speech helper
            const speak = (text) => {
                if ('speechSynthesis' in window) {
                    window.speechSynthesis.cancel();
                    
                    // –ú–∞–ø–ø–∏–Ω–≥ —Å–æ–∫—Ä–∞—â–µ–Ω–∏–π –Ω–∞ –ø–æ–ª–Ω—ã–µ –Ω–∞–∑–≤–∞–Ω–∏—è
                    const voiceNames = {
                        '—Å–±–Ω': '—Å—Ç–æ–ª–±–∏–∫ –±–µ–∑ –Ω–∞–∫–∏–¥–∞',
                        '—Å—Å–Ω': '—Å—Ç–æ–ª–±–∏–∫ —Å –Ω–∞–∫–∏–¥–æ–º',
                        '—Å—Å2–Ω': '—Å—Ç–æ–ª–±–∏–∫ —Å –¥–≤—É–º—è –Ω–∞–∫–∏–¥–∞–º–∏',
                        '—Å—Å3–Ω': '—Å—Ç–æ–ª–±–∏–∫ —Å —Ç—Ä–µ–º—è –Ω–∞–∫–∏–¥–∞–º–∏',
                        '–ø—Å—Å–Ω': '–ø–æ–ª—É—Å—Ç–æ–ª–±–∏–∫ —Å –Ω–∞–∫–∏–¥–æ–º',
                        '—Å—Å': '—Å–æ–µ–¥–∏–Ω–∏—Ç–µ–ª—å–Ω—ã–π —Å—Ç–æ–ª–±–∏–∫',
                        '–≤–ø': '–≤–æ–∑–¥—É—à–Ω–∞—è –ø–µ—Ç–ª—è',
                        '–≤–ø –ø–æ–¥—ä–µ–º–∞': '–≤–æ–∑–¥—É—à–Ω–∞—è –ø–µ—Ç–ª—è –ø–æ–¥—ä—ë–º–∞',
                        '–ø–ø': '–ø–µ—Ç–ª—è –ø–æ–¥—ä—ë–º–∞',
                        '–ø—Ä': '–ø—Ä–∏–±–∞–≤–∫–∞',
                        '—É–±': '—É–±–∞–≤–∫–∞'
                    };
                    
                    let spokenText = text;
                    
                    // –ü—Ä–æ–≤–µ—Ä—è–µ–º —Ç–æ—á–Ω—ã–µ —Å–æ–≤–ø–∞–¥–µ–Ω–∏—è (–≤–µ—Å—å —Ç–µ–∫—Å—Ç —Ü–µ–ª–∏–∫–æ–º)
                    const lowerText = text.trim().toLowerCase();
                    if (voiceNames[lowerText]) {
                        spokenText = voiceNames[lowerText];
                    } else {
                        // –ó–∞–º–µ–Ω—è–µ–º –∫–∞–∂–¥–æ–µ —Å–æ–∫—Ä–∞—â–µ–Ω–∏–µ (–æ—Ç –¥–ª–∏–Ω–Ω—ã—Ö –∫ –∫–æ—Ä–æ—Ç–∫–∏–º —á—Ç–æ–±—ã –∏–∑–±–µ–∂–∞—Ç—å –∫–æ–Ω—Ñ–ª–∏–∫—Ç–æ–≤)
                        const sortedKeys = Object.keys(voiceNames).sort((a, b) => b.length - a.length);
                        sortedKeys.forEach(short => {
                            // –ó–∞–º–µ–Ω—è–µ–º —Å —É—á—ë—Ç–æ–º –≥—Ä–∞–Ω–∏—Ü —Å–ª–æ–≤ - –¥–æ–±–∞–≤–ª—è–µ–º –ø—Ä–æ–±–µ–ª—ã/–∑–Ω–∞–∫–∏ –ø—Ä–µ–ø–∏–Ω–∞–Ω–∏—è
                            const regex = new RegExp('(^|[\\s\\.\\,\\!\\?])(' + short + ')($|[\\s\\.\\,\\!\\?])', 'gi');
                            spokenText = spokenText.replace(regex, '$1' + voiceNames[short] + '$3');
                        });
                    }
                    
                    const utterance = new SpeechSynthesisUtterance(spokenText);
                    utterance.lang = 'ru-RU';
                    utterance.rate = 0.9;
                    window.speechSynthesis.speak(utterance);
                }
            };

            // Initialize voice recognition
            useEffect(() => {
                if ('webkitSpeechRecognition' in window || 'SpeechRecognition' in window) {
                    const SpeechRecognition = window.SpeechRecognition || window.webkitSpeechRecognition;
                    const recognitionInstance = new SpeechRecognition();
                    recognitionInstance.continuous = true;
                    recognitionInstance.interimResults = true;
                    recognitionInstance.lang = 'ru-RU';
                    
                    recognitionInstance.onresult = (event) => {
                        const last = event.results.length - 1;
                        const text = event.results[last][0].transcript.toLowerCase().trim();
                        
                        if (event.results[last].isFinal) {
                            const now = Date.now();
                            
                            if (text.includes('–≥–æ—Ç–æ–≤–æ') || text.includes('–≥–æ—Ç–æ–≤')) {
                                setLastCommandTime(prevTime => {
                                    // –ó–∞—â–∏—Ç–∞ –æ—Ç –¥–≤–æ–π–Ω–æ–≥–æ —Å—Ä–∞–±–∞—Ç—ã–≤–∞–Ω–∏—è - –º–∏–Ω–∏–º—É–º 800–º—Å –º–µ–∂–¥—É –∫–æ–º–∞–Ω–¥–∞–º–∏
                                    if (now - prevTime > 800) {
                                        handleVoiceCommand();
                                        return now;
                                    }
                                    return prevTime;
                                });
                            } else if (text.includes('–Ω–∞–∑–∞–¥') || text.includes('–æ—Ç–º–µ–Ω–∞')) {
                                setLastCommandTime(prevTime => {
                                    if (now - prevTime > 800) {
                                        handleVoiceUndo();
                                        return now;
                                    }
                                    return prevTime;
                                });
                            }
                        }
                    };
                    
                    recognitionInstance.onstart = () => {
                        console.log('Voice recognition started');
                    };
                    
                    recognitionInstance.onerror = (event) => {
                        console.error('Voice recognition error:', event.error);
                        if (event.error === 'not-allowed') {
                            alert('–ü–æ–∂–∞–ª—É–π—Å—Ç–∞, —Ä–∞–∑—Ä–µ—à–∏—Ç–µ –¥–æ—Å—Ç—É–ø –∫ –º–∏–∫—Ä–æ—Ñ–æ–Ω—É –≤ –Ω–∞—Å—Ç—Ä–æ–π–∫–∞—Ö –±—Ä–∞—É–∑–µ—Ä–∞');
                        }
                        setIsListening(false);
                    };
                    
                    recognitionInstance.onend = () => {
                        console.log('Voice recognition ended, restarting...');
                        setTimeout(() => {
                            if (isListeningRef.current && modeRef.current === 'knitting' && !isPausedRef.current) {
                                try {
                                    recognitionInstance.start();
                                    console.log('Restarted successfully');
                                } catch (e) {
                                    console.error('Failed to restart:', e);
                                }
                            }
                        }, 300);
                    };
                    
                    setRecognition(recognitionInstance);
                }
            }, [handleVoiceCommand, handleVoiceUndo]);

            // Handle voice recognition start/stop
            useEffect(() => {
                if (recognition) {
                    if (isListening && mode === 'knitting' && !isPaused) {
                        try {
                            recognition.start();
                        } catch (e) {
                            console.log('Recognition already started');
                        }
                    } else {
                        try {
                            recognition.stop();
                        } catch (e) {
                            console.log('Recognition already stopped');
                        }
                    }
                }
            }, [isListening, mode, isPaused, recognition]);

            const toggleVoiceControl = () => {
                setIsListening(!isListening);
            };

            const addToPattern = (element) => {
                setCurrentRowPattern([...currentRowPattern, { type: element, stitches: 1, balance: 0, outputStitches: 1, repeatCount: 1 }]);
            };

            const addIncrease = () => {
                setCurrentRowPattern([...currentRowPattern, { type: '–ø—Ä', stitches: 1, balance: 1, outputStitches: 2, repeatCount: 1 }]);
            };

            const addDecrease = () => {
                setCurrentRowPattern([...currentRowPattern, { type: '—É–±', stitches: 1, balance: -1, outputStitches: 1, repeatCount: 1 }]);
            };

            const addCustomElement = () => {
                if (customInput.trim()) {
                    setCurrentRowPattern([...currentRowPattern, { 
                        type: customInput.trim(), 
                        stitches: customStitches,
                        balance: customBalance,
                        outputStitches: 1 + customBalance
                    }]);
                    setCustomInput('');
                    setCustomStitches(1);
                    setCustomBalance(0);
                }
            };
            
            const addColorChange = () => {
                if (colorInput.trim()) {
                    setCurrentRowPattern([...currentRowPattern, {
                        type: 'COLOR_CHANGE',
                        color: colorInput.trim(),
                        isMarker: true,
                        stitches: 0,
                        balance: 0,
                        outputStitches: 0
                    }]);
                    setColorInput('');
                }
            };

            const removeLastFromPattern = () => setCurrentRowPattern(currentRowPattern.slice(0, -1));

            const addRow = () => {
                if (currentRowPattern.length > 0) {
                    // –†–∞–∑–≤–æ—Ä–∞—á–∏–≤–∞–µ–º repeatCount –¥–ª—è –∫–∞–∂–¥–æ–≥–æ —ç–ª–µ–º–µ–Ω—Ç–∞
                    const expandedPattern = currentRowPattern.flatMap(elem => {
                        const count = elem.repeatCount || 1;
                        return Array(count).fill({ ...elem, repeatCount: undefined });
                    });
                    
                    // –ü—Ä–∏–º–µ–Ω—è–µ–º –≥–ª–æ–±–∞–ª—å–Ω–æ–µ –ø–æ–≤—Ç–æ—Ä–µ–Ω–∏–µ —Ä—è–¥–∞
                    const repeatedPattern = Array(repeatCount).fill(expandedPattern).flat();
                    
                    // –ü—Ä–æ–≤–µ—Ä–∫–∞ —Å–æ–æ—Ç–≤–µ—Ç—Å—Ç–≤–∏—è –ø–∞—Ç—Ç–µ—Ä–Ω–∞ –ø—Ä–µ–¥—ã–¥—É—â–µ–º—É —Ä—è–¥—É (–ø—Ä–æ–ø—É—Å–∫–∞–µ–º –ø—Ä–∏ —Ä–µ–¥–∞–∫—Ç–∏—Ä–æ–≤–∞–Ω–∏–∏)
                    if (!isEditingRow) {
                        const previousOutput = manualInitialStitches.trim() !== '' 
                            ? parseInt(manualInitialStitches)
                            : (rows.length > 0 ? getCurrentRowStitches(rows.length - 1) : 0);
                        
                        if (previousOutput > 0) {
                            const requiredInput = repeatedPattern.reduce((sum, element) => {
                                if (element.isMarker) return sum; // –ü—Ä–æ–ø—É—Å–∫–∞–µ–º –º–∞—Ä–∫–µ—Ä—ã
                                const inputStitches = element.outputStitches - element.balance;
                                return sum + inputStitches;
                            }, 0);
                            
                            if (requiredInput !== previousOutput) {
                                alert(
                                    '‚ùå –û—à–∏–±–∫–∞ –≤ –ø–∞—Ç—Ç–µ—Ä–Ω–µ!\n\n' +
                                    '–ü–∞—Ç—Ç–µ—Ä–Ω —Ç—Ä–µ–±—É–µ—Ç: ' + requiredInput + ' –ø–µ—Ç–µ–ª—å\n' +
                                    '–í –ø—Ä–µ–¥—ã–¥—É—â–µ–º —Ä—è–¥—É: ' + previousOutput + ' –ø–µ—Ç–µ–ª—å\n\n' +
                                    '–ò—Å–ø—Ä–∞–≤—å—Ç–µ –ø–∞—Ç—Ç–µ—Ä–Ω –∏–ª–∏ –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ –ø–µ—Ç–µ–ª—å!'
                                );
                                return;
                            }
                        }
                    }
                    
                    // –í–∞–ª–∏–¥–∞—Ü–∏—è
                    if (rows.length > 0 && manualInitialStitches.trim() !== '') {
                        const manualValue = parseInt(manualInitialStitches);
                        const autoCalculated = getCurrentRowStitches(rows.length - 1);
                        
                        if (manualValue !== autoCalculated) {
                            const confirmed = confirm(
                                '‚ö†Ô∏è –í–Ω–∏–º–∞–Ω–∏–µ!\n\n' +
                                '–í –†—è–¥—É ' + rows.length + ' –ø–æ–ª—É—á–∏–ª–æ—Å—å ' + autoCalculated + ' –ø–µ—Ç–µ–ª—å,\n' +
                                '–Ω–æ —Ç—ã —É–∫–∞–∑–∞–ª–∞ ' + manualValue + ' –ø–µ—Ç–µ–ª—å.\n\n' +
                                '–ü—Ä–æ–¥–æ–ª–∂–∏—Ç—å?'
                            );
                            if (!confirmed) return;
                        }
                    }
                    
                    const newRow = {
                        pattern: repeatedPattern,
                        rowNumber: currentRowNumber,
                        manualStitches: manualInitialStitches.trim() !== '' ? parseInt(manualInitialStitches) : undefined
                    };
                    
                    // –ü—Ä–∏ —Ä–µ–¥–∞–∫—Ç–∏—Ä–æ–≤–∞–Ω–∏–∏ –≤—Å—Ç–∞–≤–ª—è–µ–º –Ω–∞ –ø—Ä–∞–≤–∏–ª—å–Ω–æ–µ –º–µ—Å—Ç–æ
                    let updatedRows;
                    if (isEditingRow && editingRowNumber !== null) {
                        updatedRows = [...rows];
                        updatedRows.splice(editingRowNumber, 0, newRow);
                        setRows(updatedRows);
                    } else {
                        updatedRows = [...rows, newRow];
                        setRows(updatedRows);
                    }
                    
                    // –Ø–≤–Ω–æ —Å–æ—Ö—Ä–∞–Ω—è–µ–º
                    saveRowsForScheme(currentSchemeId, updatedRows);
                    
                    setCurrentRowPattern([]);
                    setRepeatCount(1);
                    
                    // –£–≤–µ–ª–∏—á–∏–≤–∞–µ–º –Ω–æ–º–µ—Ä —Ç–æ–ª—å–∫–æ –µ—Å–ª–∏ –Ω–µ —Ä–µ–¥–∞–∫—Ç–∏—Ä—É–µ–º
                    if (!isEditingRow) {
                        setCurrentRowNumber(currentRowNumber + 1);
                    }
                    
                    setManualInitialStitches('');
                    
                    // –°–±—Ä–∞—Å—ã–≤–∞–µ–º —Ñ–ª–∞–≥ —Ä–µ–¥–∞–∫—Ç–∏—Ä–æ–≤–∞–Ω–∏—è
                    setIsEditingRow(false);
                    setEditingRowNumber(null);
                }
            };

            const deleteRow = (index) => {
                const updated = rows.filter((_, i) => i !== index);
                setRows(updated);
                saveRowsForScheme(currentSchemeId, updated);
            };
            
            const editRow = (index) => {
                const row = rows[index];
                
                // –ó–∞–≥—Ä—É–∂–∞–µ–º –ø–∞—Ç—Ç–µ—Ä–Ω —Ä—è–¥–∞ –≤ —Ä–µ–¥–∞–∫—Ç–æ—Ä
                // –í–æ—Å—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ–º repeatCount –∏–∑ —Å–∂–∞—Ç–æ–≥–æ –ø–∞—Ç—Ç–µ—Ä–Ω–∞
                const patternWithRepeatCount = row.pattern.map(elem => ({ ...elem, repeatCount: 1 }));
                setCurrentRowPattern(patternWithRepeatCount);
                setCurrentRowNumber(row.rowNumber);
                setManualInitialStitches(row.manualStitches || '');
                
                // –£—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ–º —Ñ–ª–∞–≥ —Ä–µ–¥–∞–∫—Ç–∏—Ä–æ–≤–∞–Ω–∏—è —Å –∏–Ω–¥–µ–∫—Å–æ–º
                setIsEditingRow(true);
                setEditingRowNumber(index); // –°–æ—Ö—Ä–∞–Ω—è–µ–º –∏–Ω–¥–µ–∫—Å –≤–º–µ—Å—Ç–æ –Ω–æ–º–µ—Ä–∞
                
                // –£–¥–∞–ª—è–µ–º —Ä—è–¥ –∏–∑ —Å–ø–∏—Å–∫–∞ (–±—É–¥–µ—Ç –ø–µ—Ä–µ—Å–æ–∑–¥–∞–Ω –ø—Ä–∏ —Å–æ—Ö—Ä–∞–Ω–µ–Ω–∏–∏)
                setRows(rows.filter((_, i) => i !== index));
            };
            
            const openElementModal = (element) => {
                setSelectedElement(element);
                setElementRepeatCount(1);
                setElementModalOpen(true);
            };
            
            const closeElementModal = () => {
                setElementModalOpen(false);
                setSelectedElement(null);
                setElementRepeatCount(1);
            };
            
            const confirmAddElement = () => {
                if (selectedElement && elementRepeatCount > 0) {
                    for (let i = 0; i < elementRepeatCount; i++) {
                        setCurrentRowPattern(prev => [...prev, selectedElement]);
                    }
                    closeElementModal();
                }
            };
            
            const groupConsecutiveElements = (pattern) => {
                if (pattern.length === 0) return [];
                
                const grouped = [];
                let currentGroup = { element: pattern[0], count: 1 };
                
                for (let i = 1; i < pattern.length; i++) {
                    const current = pattern[i];
                    const prev = pattern[i - 1];
                    
                    // –ü—Ä–æ–≤–µ—Ä—è–µ–º –∏–¥–µ–Ω—Ç–∏—á–Ω–æ—Å—Ç—å —ç–ª–µ–º–µ–Ω—Ç–æ–≤
                    if (current.type === prev.type && 
                        current.stitches === prev.stitches && 
                        current.balance === prev.balance &&
                        !current.isMarker) {
                        currentGroup.count++;
                    } else {
                        grouped.push(currentGroup);
                        currentGroup = { element: current, count: 1 };
                    }
                }
                grouped.push(currentGroup);
                
                return grouped;
            };
            
            const updateElementRepeatCount = (index, newCount) => {
                if (newCount >= 1) {
                    const updated = [...currentRowPattern];
                    updated[index] = { ...updated[index], repeatCount: newCount };
                    setCurrentRowPattern(updated);
                }
                setEditingElementIndex(null);
            };
            
            const openRepeatRowDialog = (index) => {
                setRepeatRowIndex(index);
                setRepeatRowCount(1);
            };
            
            const closeRepeatRowDialog = () => {
                setRepeatRowIndex(null);
                setRepeatRowCount(1);
            };
            
            const confirmRepeatRow = () => {
                if (repeatRowIndex !== null && repeatRowCount > 0 && repeatRowCount <= 20) {
                    const rowToRepeat = rows[repeatRowIndex];
                    const newRows = [];
                    
                    for (let i = 0; i < repeatRowCount; i++) {
                        newRows.push({
                            pattern: rowToRepeat.pattern,
                            rowNumber: rows.length + i + 1,
                            manualStitches: rowToRepeat.manualStitches
                        });
                    }
                    
                    setRows([...rows, ...newRows]);
                    setCurrentRowNumber(rows.length + repeatRowCount + 1);
                    closeRepeatRowDialog();
                }
            };

            const startKnitting = () => {
                if (rows.length > 0) {
                    setMode('knitting');
                    setCurrentRow(0);
                    setCurrentElement(0);
                    setHistory([]);
                }
            };

            const markStitchDone = () => {
                const currentPattern = rows[currentRow].pattern;
                const currentElementData = currentPattern[currentElement];
                
                setHistory([...history, currentElementData]);
                
                if (currentElement < currentPattern.length - 1) {
                    setCurrentElement(currentElement + 1);
                    
                    // –û–∑–≤—É—á–∫–∞ —Å–ª–µ–¥—É—é—â–µ–≥–æ —ç–ª–µ–º–µ–Ω—Ç–∞
                    if (voiceFeedback) {
                        const nextElement = currentPattern[currentElement + 1];
                        
                        // –ï—Å–ª–∏ —ç—Ç–æ —Å–º–µ–Ω–∞ —Ü–≤–µ—Ç–∞ - –æ–∑–≤—É—á–∏—Ç—å
                        if (nextElement.type === 'COLOR_CHANGE') {
                            speak('–°–º–µ–Ω–∏ —Ü–≤–µ—Ç –Ω–∞ ' + nextElement.color);
                        } else if (nextElement.stitches > 1) {
                            speak(nextElement.type + ', ' + nextElement.stitches + ' –ø—Ä–æ–≤—è–∑–æ–≤');
                        } else {
                            speak(nextElement.type);
                        }
                    }
                } else {
                    if (currentRow < rows.length - 1) {
                        setCurrentRow(currentRow + 1);
                        setCurrentElement(0);
                        setHistory([]);
                        
                        // –û–∑–≤—É—á–∫–∞ –Ω–æ–≤–æ–≥–æ —Ä—è–¥–∞
                        if (voiceFeedback) {
                            const nextRow = rows[currentRow + 1].pattern;
                            const firstElement = nextRow[0];
                            
                            if (firstElement.type === 'COLOR_CHANGE') {
                                speak('–†—è–¥ ' + rows[currentRow + 1].rowNumber + '. –°–º–µ–Ω–∏ —Ü–≤–µ—Ç –Ω–∞ ' + firstElement.color);
                            } else if (firstElement.stitches > 1) {
                                speak('–†—è–¥ ' + rows[currentRow + 1].rowNumber + '. ' + firstElement.type + ', ' + firstElement.stitches + ' –ø—Ä–æ–≤—è–∑–æ–≤');
                            } else {
                                speak('–†—è–¥ ' + rows[currentRow + 1].rowNumber + '. ' + firstElement.type);
                            }
                        }
                    } else {
                        if (currentPartIndex !== null) {
                            completePartInstance();
                        } else {
                            alert('üéâ –ü–æ–∑–¥—Ä–∞–≤–ª—è—é! –¢—ã –∑–∞–≤–µ—Ä—à–∏–ª–∞ –≤—Å–µ —Ä—è–¥—ã!');
                            setMode('setup');
                        }
                    }
                }
            };

            const undoLast = () => {
                if (currentElement > 0) {
                    setCurrentElement(currentElement - 1);
                    setHistory(history.slice(0, -1));
                    
                    // Voice feedback for undo
                    if (voiceFeedback) {
                        const currentPattern = rows[currentRow].pattern;
                        const newCurrentElement = currentPattern[currentElement - 1];
                        
                        if (newCurrentElement.type === 'COLOR_CHANGE') {
                            speak('–ù–∞–∑–∞–¥. –°–º–µ–Ω–∏ —Ü–≤–µ—Ç –Ω–∞ ' + newCurrentElement.color);
                        } else if (newCurrentElement.stitches > 1) {
                            speak('–ù–∞–∑–∞–¥. ' + newCurrentElement.type + ', ' + newCurrentElement.stitches + ' –ø—Ä–æ–≤—è–∑–æ–≤');
                        } else {
                            speak('–ù–∞–∑–∞–¥. ' + newCurrentElement.type);
                        }
                    }
                } else if (currentRow > 0) {
                    const prevRow = rows[currentRow - 1].pattern;
                    setCurrentRow(currentRow - 1);
                    setCurrentElement(prevRow.length - 1);
                    setHistory(prevRow.slice(0, -1));
                    
                    // Voice feedback when going back to previous row
                    if (voiceFeedback) {
                        const newCurrentElement = prevRow[prevRow.length - 1];
                        
                        if (newCurrentElement.type === 'COLOR_CHANGE') {
                            speak('–ù–∞–∑–∞–¥ –≤ —Ä—è–¥ ' + rows[currentRow - 1].rowNumber + '. –°–º–µ–Ω–∏ —Ü–≤–µ—Ç –Ω–∞ ' + newCurrentElement.color);
                        } else if (newCurrentElement.stitches > 1) {
                            speak('–ù–∞–∑–∞–¥. –†—è–¥ ' + rows[currentRow - 1].rowNumber + '. ' + newCurrentElement.type + ', ' + newCurrentElement.stitches + ' –ø—Ä–æ–≤—è–∑–æ–≤');
                        } else {
                            speak('–ù–∞–∑–∞–¥. –†—è–¥ ' + rows[currentRow - 1].rowNumber + '. ' + newCurrentElement.type);
                        }
                    }
                }
            };

            const editCounter = () => {
                const newRow = prompt('–í–≤–µ–¥–∏—Ç–µ –Ω–æ–º–µ—Ä —Ä—è–¥–∞ (1-' + rows.length + '):', currentRow + 1);
                const newElement = prompt('–í–≤–µ–¥–∏—Ç–µ –Ω–æ–º–µ—Ä —ç–ª–µ–º–µ–Ω—Ç–∞:', currentElement + 1);
                
                if (newRow && newElement) {
                    const rowNum = parseInt(newRow) - 1;
                    const elemNum = parseInt(newElement) - 1;
                    
                    if (rowNum >= 0 && rowNum < rows.length && elemNum >= 0 && elemNum < rows[rowNum].pattern.length) {
                        setCurrentRow(rowNum);
                        setCurrentElement(elemNum);
                        setHistory(rows[rowNum].pattern.slice(0, elemNum));
                    }
                }
            };

            const getTotalStitches = (pattern) => pattern.reduce((sum, elem) => sum + elem.stitches, 0);
            
            const getStitchBalance = (pattern) => pattern.reduce((sum, elem) => {
                const elRepeat = elem.repeatCount || 1;
                return sum + (elem.balance * elRepeat);
            }, 0);
            
            const getFirstRowOutputStitches = (pattern) => pattern.reduce((sum, elem) => {
                const elRepeat = elem.repeatCount || 1;
                return sum + (elem.outputStitches * elRepeat);
            }, 0);
            
            const getPreviousRowStitches = (rowIndex) => {
                if (rowIndex === 0) return 0;
                
                // –ü—Ä–æ–≤–µ—Ä—è–µ–º –µ—Å—Ç—å –ª–∏ —Ä—É—á–Ω–æ–π –≤–≤–æ–¥ –¥–ª—è –ø–µ—Ä–≤–æ–≥–æ —Ä—è–¥–∞
                if (rows[0] && rows[0].manualStitches !== undefined) {
                    let total = rows[0].manualStitches + getStitchBalance(rows[0].pattern);
                    for (let i = 1; i < rowIndex; i++) {
                        if (rows[i].manualStitches !== undefined) {
                            total = rows[i].manualStitches + getStitchBalance(rows[i].pattern);
                        } else {
                            total += getStitchBalance(rows[i].pattern);
                        }
                    }
                    return total;
                }
                
                // –ê–≤—Ç–æ–ø–æ–¥—Å—á—ë—Ç
                let total = getFirstRowOutputStitches(rows[0].pattern);
                for (let i = 1; i < rowIndex; i++) {
                    if (rows[i].manualStitches !== undefined) {
                        total = rows[i].manualStitches + getStitchBalance(rows[i].pattern);
                    } else {
                        total += getStitchBalance(rows[i].pattern);
                    }
                }
                return total;
            };
            
            const getCurrentRowStitches = (rowIndex) => {
                if (rowIndex === 0) {
                    // –î–ª—è –ø–µ—Ä–≤–æ–≥–æ —Ä—è–¥–∞ - –µ—Å–ª–∏ –µ—Å—Ç—å —Ä—É—á–Ω–æ–π –≤–≤–æ–¥, –∏—Å–ø–æ–ª—å–∑—É–µ–º –µ–≥–æ + –±–∞–ª–∞–Ω—Å
                    if (rows[0] && rows[0].manualStitches !== undefined) {
                        return rows[0].manualStitches + getStitchBalance(rows[0].pattern);
                    }
                    return getFirstRowOutputStitches(rows[rowIndex].pattern);
                }
                return getPreviousRowStitches(rowIndex) + getStitchBalance(rows[rowIndex].pattern);
            };

            const getCompletedStitches = (hist) => {
                let completed = 0;
                hist.forEach(elem => { completed += elem.stitches; });
                return completed;
            };
            
            const getCompletedPetels = (rowIndex, hist) => {
                // –ü—Ä–æ—Å—Ç–æ –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ –∑–∞–≤–µ—Ä—à—ë–Ω–Ω—ã—Ö —ç–ª–µ–º–µ–Ω—Ç–æ–≤ –≤ —Ç–µ–∫—É—â–µ–º —Ä—è–¥—É
                return hist.length;
            };
            
            // Helper functions for scheme-specific row storage
            const saveRowsForScheme = (schemeId, rowsData) => {
                const key = 'rows_' + schemeId;
                localStorage.setItem(key, JSON.stringify(rowsData));
            };
            
            const loadRowsForScheme = (schemeId) => {
                const key = 'rows_' + schemeId;
                const saved = localStorage.getItem(key);
                return saved ? JSON.parse(saved) : [];
            };
            
            const returnToMainScreen = () => {
                // –°–æ—Ö—Ä–∞–Ω—è–µ–º —Ç–µ–∫—É—â–∏–µ —Ä—è–¥—ã
                saveRowsForScheme(currentSchemeId, rows);
                
                // –ü–µ—Ä–µ–∫–ª—é—á–∞–µ–º—Å—è –Ω–∞ manual
                setCurrentSchemeId('manual');
                setCurrentScheme(null);
                
                // –ó–∞–≥—Ä—É–∂–∞–µ–º —Ä—è–¥—ã –¥–ª—è manual
                const manualRows = loadRowsForScheme('manual');
                setRows(manualRows);
                
                setSchemeMode('main');
            };
            
            const startSchemeCreation = () => {
                // –°–æ—Ö—Ä–∞–Ω—è–µ–º —Ç–µ–∫—É—â–∏–µ —Ä—è–¥—ã manual
                saveRowsForScheme(currentSchemeId, rows);
                
                // –ü–µ—Ä–µ–∫–ª—é—á–∞–µ–º—Å—è –Ω–∞ —Ä–µ–∂–∏–º —Å–æ–∑–¥–∞–Ω–∏—è —Å—Ö–µ–º—ã —Å –ø—É—Å—Ç—ã–º–∏ —Ä—è–¥–∞–º–∏
                setCurrentSchemeId('scheme_creating');
                setRows([]);
                setCurrentRowPattern([]);
                setCurrentRowNumber(1);
                setSchemeMode('create-scheme');
            };
            
            // Scheme functions
            const loadSchemesList = async () => {
                try {
                    // Load from server
                    const response = await fetch('./schemes/schemes-list.json');
                    const data = await response.json();
                    const serverSchemes = data.schemes || [];
                    
                    // Load from localStorage
                    const localSchemes = JSON.parse(localStorage.getItem('local_schemes') || '[]');
                    
                    // Mark local schemes
                    localSchemes.forEach(scheme => {
                        scheme.isLocal = true;
                        if (!scheme.totalParts) {
                            scheme.totalParts = scheme.parts.length;
                        }
                        if (!scheme.totalRows) {
                            scheme.totalRows = scheme.parts.reduce((sum, p) => sum + p.rows.length, 0);
                        }
                    });
                    
                    // Combine both
                    setAvailableSchemes([...serverSchemes, ...localSchemes]);
                } catch (error) {
                    console.error('Error loading schemes:', error);
                    // If server schemes fail, still load local
                    const localSchemes = JSON.parse(localStorage.getItem('local_schemes') || '[]');
                    localSchemes.forEach(scheme => {
                        scheme.isLocal = true;
                        if (!scheme.totalParts) scheme.totalParts = scheme.parts.length;
                        if (!scheme.totalRows) scheme.totalRows = scheme.parts.reduce((sum, p) => sum + p.rows.length, 0);
                    });
                    setAvailableSchemes(localSchemes);
                }
            };
            
            const loadScheme = async (schemeId) => {
                try {
                    // –°–æ—Ö—Ä–∞–Ω—è–µ–º —Ç–µ–∫—É—â–∏–µ —Ä—è–¥—ã –ø–µ—Ä–µ–¥ –ø–µ—Ä–µ–∫–ª—é—á–µ–Ω–∏–µ–º
                    saveRowsForScheme(currentSchemeId, rows);
                    
                    // First check if it's a local scheme
                    const localSchemes = JSON.parse(localStorage.getItem('local_schemes') || '[]');
                    const localScheme = localSchemes.find(s => s.id === schemeId);
                    
                    if (localScheme) {
                        setCurrentScheme(localScheme);
                    } else {
                        // Load from server
                        const response = await fetch('./schemes/' + schemeId + '.json');
                        const data = await response.json();
                        setCurrentScheme(data);
                    }
                    
                    const savedProgress = localStorage.getItem('scheme_progress_' + schemeId);
                    if (savedProgress) {
                        setSchemeProgress(JSON.parse(savedProgress));
                    } else {
                        setSchemeProgress({});
                    }
                    
                    // –£—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ–º ID —Å—Ö–µ–º—ã
                    setCurrentSchemeId(schemeId);
                    
                    // –ó–∞–≥—Ä—É–∂–∞–µ–º —Ä—è–¥—ã –¥–ª—è —ç—Ç–æ–π —Å—Ö–µ–º—ã
                    const savedRows = loadRowsForScheme(schemeId);
                    setRows(savedRows);
                    
                    setSchemeMode('scheme-details');
                } catch (error) {
                    console.error('Error loading scheme:', error);
                    alert('–û—à–∏–±–∫–∞ –∑–∞–≥—Ä—É–∑–∫–∏ —Å—Ö–µ–º—ã');
                }
            };
            
            const startKnittingPart = (partIndex, instanceIndex) => {
                const part = currentScheme.parts[partIndex];
                setRows(part.rows);
                setCurrentRow(0);
                setCurrentElement(0);
                setHistory([]);
                setCurrentPartIndex(partIndex);
                setCurrentInstanceIndex(instanceIndex);
                setMode('knitting');
            };
            
            const completePartInstance = () => {
                const key = currentPartIndex + '_' + currentInstanceIndex;
                const newProgress = { ...schemeProgress };
                newProgress[key] = true;
                setSchemeProgress(newProgress);
                
                localStorage.setItem('scheme_progress_' + currentScheme.id, JSON.stringify(newProgress));
                
                setMode('setup');
                setSchemeMode('scheme-details');
                setCurrentPartIndex(null);
                setCurrentInstanceIndex(0);
                alert('üéâ –î–µ—Ç–∞–ª—å –∑–∞–≤–µ—Ä—à–µ–Ω–∞!');
            };
            
            const exportSchemeToJSON = () => {
                const scheme = {
                    id: newSchemeName.toLowerCase().replace(/\s+/g, '-'),
                    name: newSchemeName,
                    emoji: newSchemeEmoji,
                    difficulty: newSchemeDifficulty,
                    parts: schemeParts
                };
                
                // Calculate totals
                scheme.totalParts = schemeParts.reduce((sum, p) => sum + p.quantity, 0);
                scheme.totalRows = schemeParts.reduce((sum, p) => sum + p.rows.length * p.quantity, 0);
                
                const dataStr = JSON.stringify(scheme, null, 2);
                const dataUri = 'data:application/json;charset=utf-8,'+ encodeURIComponent(dataStr);
                const fileName = scheme.id + '.json';
                
                const linkElement = document.createElement('a');
                linkElement.setAttribute('href', dataUri);
                linkElement.setAttribute('download', fileName);
                linkElement.click();
                
                alert('‚úÖ –§–∞–π–ª —Å—Ö–µ–º—ã —Å–æ—Ö—Ä–∞–Ω—ë–Ω –≤ –ó–∞–≥—Ä—É–∑–∫–∏!');
            };
            
            const saveSchemeLocally = () => {
                if (!newSchemeName.trim()) {
                    alert('–í–≤–µ–¥–∏—Ç–µ –Ω–∞–∑–≤–∞–Ω–∏–µ —Å—Ö–µ–º—ã');
                    return;
                }
                
                if (schemeParts.length === 0) {
                    alert('–î–æ–±–∞–≤—å—Ç–µ —Ö–æ—Ç—è –±—ã –æ–¥–Ω—É –¥–µ—Ç–∞–ª—å');
                    return;
                }
                
                const scheme = {
                    id: newSchemeName.toLowerCase().replace(/\s+/g, '-'),
                    name: newSchemeName,
                    emoji: newSchemeEmoji,
                    difficulty: newSchemeDifficulty,
                    parts: schemeParts,
                    isLocal: true
                };
                
                // Calculate totals
                scheme.totalParts = schemeParts.reduce((sum, p) => sum + p.quantity, 0);
                scheme.totalRows = schemeParts.reduce((sum, p) => sum + p.rows.length * p.quantity, 0);
                
                // Save to localStorage
                const localSchemes = JSON.parse(localStorage.getItem('local_schemes') || '[]');
                const existingIndex = localSchemes.findIndex(s => s.id === scheme.id);
                
                if (existingIndex >= 0) {
                    localSchemes[existingIndex] = scheme;
                } else {
                    localSchemes.push(scheme);
                }
                
                localStorage.setItem('local_schemes', JSON.stringify(localSchemes));
                
                // Reset form and go to library
                setNewSchemeName('');
                setNewSchemeEmoji('üß∏');
                setNewSchemeDifficulty('–°—Ä–µ–¥–Ω–∏–π');
                setSchemeParts([]);
                loadSchemesList();
                setSchemeMode('library');
                
                alert('‚úÖ –°—Ö–µ–º–∞ —Å–æ—Ö—Ä–∞–Ω–µ–Ω–∞ –≤ –±—Ä–∞—É–∑–µ—Ä–µ!');
            };
            
            const importSchemeFromFile = () => {
                const input = document.createElement('input');
                input.type = 'file';
                input.accept = '.json';
                input.onchange = (e) => {
                    const file = e.target.files[0];
                    if (!file) return;
                    
                    const reader = new FileReader();
                    reader.onload = (event) => {
                        try {
                            const scheme = JSON.parse(event.target.result);
                            
                            // Validate scheme structure
                            if (!scheme.name || !scheme.parts || !Array.isArray(scheme.parts)) {
                                alert('‚ùå –ù–µ–≤–µ—Ä–Ω—ã–π —Ñ–æ—Ä–º–∞—Ç —Ñ–∞–π–ª–∞ —Å—Ö–µ–º—ã');
                                return;
                            }
                            
                            // Mark as local
                            scheme.isLocal = true;
                            
                            // Calculate totals if missing
                            if (!scheme.totalParts) {
                                scheme.totalParts = scheme.parts.reduce((sum, p) => sum + p.quantity, 0);
                            }
                            if (!scheme.totalRows) {
                                scheme.totalRows = scheme.parts.reduce((sum, p) => sum + p.rows.length * p.quantity, 0);
                            }
                            
                            // Save to localStorage
                            const localSchemes = JSON.parse(localStorage.getItem('local_schemes') || '[]');
                            
                            // Check if already exists
                            const existingIndex = localSchemes.findIndex(s => s.id === scheme.id);
                            if (existingIndex >= 0) {
                                if (!confirm('–°—Ö–µ–º–∞ "' + scheme.name + '" —É–∂–µ —Å—É—â–µ—Å—Ç–≤—É–µ—Ç. –ó–∞–º–µ–Ω–∏—Ç—å?')) {
                                    return;
                                }
                                localSchemes[existingIndex] = scheme;
                            } else {
                                localSchemes.push(scheme);
                            }
                            
                            localStorage.setItem('local_schemes', JSON.stringify(localSchemes));
                            
                            // Reload available schemes
                            loadSchemesList();
                            
                            alert('‚úÖ –°—Ö–µ–º–∞ "' + scheme.name + '" —É—Å–ø–µ—à–Ω–æ –∏–º–ø–æ—Ä—Ç–∏—Ä–æ–≤–∞–Ω–∞!');
                        } catch (error) {
                            console.error('Import error:', error);
                            alert('‚ùå –û—à–∏–±–∫–∞ —á—Ç–µ–Ω–∏—è —Ñ–∞–π–ª–∞. –ü—Ä–æ–≤–µ—Ä—å—Ç–µ —Ñ–æ—Ä–º–∞—Ç JSON.');
                        }
                    };
                    reader.readAsText(file);
                };
                input.click();
            };
            
            const deleteLocalScheme = (schemeId) => {
                if (!confirm('–£–¥–∞–ª–∏—Ç—å —ç—Ç—É —Å—Ö–µ–º—É –∏–∑ –ª–æ–∫–∞–ª—å–Ω–æ–≥–æ —Ö—Ä–∞–Ω–∏–ª–∏—â–∞?')) return;
                
                const localSchemes = JSON.parse(localStorage.getItem('local_schemes') || '[]');
                const filtered = localSchemes.filter(s => s.id !== schemeId);
                localStorage.setItem('local_schemes', JSON.stringify(filtered));
                
                // Also delete progress
                localStorage.removeItem('scheme_progress_' + schemeId);
                
                loadSchemesList();
                setSchemeMode('library');
                alert('‚úÖ –°—Ö–µ–º–∞ —É–¥–∞–ª–µ–Ω–∞');
            };
            
            const resetAllProgress = () => {
                if (!confirm('–°–±—Ä–æ—Å–∏—Ç—å –≤–µ—Å—å –ø—Ä–æ–≥—Ä–µ—Å—Å —ç—Ç–æ–π —Å—Ö–µ–º—ã?')) return;
                
                setSchemeProgress({});
                localStorage.setItem('scheme_progress_' + currentScheme.id, JSON.stringify({}));
                alert('‚úÖ –ü—Ä–æ–≥—Ä–µ—Å—Å —Å–±—Ä–æ—à–µ–Ω');
            };
            
            const resetPartProgress = (partIndex, instanceIndex) => {
                if (!confirm('–°–±—Ä–æ—Å–∏—Ç—å –ø—Ä–æ–≥—Ä–µ—Å—Å —ç—Ç–æ–π –¥–µ—Ç–∞–ª–∏?')) return;
                
                const key = partIndex + '_' + instanceIndex;
                const newProgress = { ...schemeProgress };
                delete newProgress[key];
                setSchemeProgress(newProgress);
                localStorage.setItem('scheme_progress_' + currentScheme.id, JSON.stringify(newProgress));
                alert('‚úÖ –ü—Ä–æ–≥—Ä–µ—Å—Å –¥–µ—Ç–∞–ª–∏ —Å–±—Ä–æ—à–µ–Ω');
            };
            
            const startEditingScheme = () => {
                setEditingScheme(currentScheme);
                setNewSchemeName(currentScheme.name);
                setNewSchemeEmoji(currentScheme.emoji);
                setNewSchemeDifficulty(currentScheme.difficulty);
                setSchemeParts(currentScheme.parts);
                setSchemeMode('edit-scheme');
            };
            
            const saveEditedScheme = () => {
                if (!newSchemeName.trim()) {
                    alert('–í–≤–µ–¥–∏—Ç–µ –Ω–∞–∑–≤–∞–Ω–∏–µ —Å—Ö–µ–º—ã');
                    return;
                }
                
                const updatedScheme = {
                    id: editingScheme.id,
                    name: newSchemeName,
                    emoji: newSchemeEmoji,
                    difficulty: newSchemeDifficulty,
                    parts: schemeParts,
                    isLocal: true
                };
                
                // Calculate totals
                updatedScheme.totalParts = schemeParts.reduce((sum, p) => sum + p.quantity, 0);
                updatedScheme.totalRows = schemeParts.reduce((sum, p) => sum + p.rows.length * p.quantity, 0);
                
                // Update in localStorage
                const localSchemes = JSON.parse(localStorage.getItem('local_schemes') || '[]');
                const index = localSchemes.findIndex(s => s.id === editingScheme.id);
                if (index >= 0) {
                    localSchemes[index] = updatedScheme;
                } else {
                    localSchemes.push(updatedScheme);
                }
                localStorage.setItem('local_schemes', JSON.stringify(localSchemes));
                
                // Update current scheme
                setCurrentScheme(updatedScheme);
                setEditingScheme(null);
                setSchemeMode('scheme-details');
                loadSchemesList();
                alert('‚úÖ –°—Ö–µ–º–∞ –æ–±–Ω–æ–≤–ª–µ–Ω–∞!');
            };
            
            const exportEditedScheme = () => {
                const scheme = {
                    id: editingScheme.id,
                    name: newSchemeName,
                    emoji: newSchemeEmoji,
                    difficulty: newSchemeDifficulty,
                    parts: schemeParts
                };
                
                scheme.totalParts = schemeParts.reduce((sum, p) => sum + p.quantity, 0);
                scheme.totalRows = schemeParts.reduce((sum, p) => sum + p.rows.length * p.quantity, 0);
                
                const dataStr = JSON.stringify(scheme, null, 2);
                const dataUri = 'data:application/json;charset=utf-8,'+ encodeURIComponent(dataStr);
                const fileName = scheme.id + '.json';
                
                const linkElement = document.createElement('a');
                linkElement.setAttribute('href', dataUri);
                linkElement.setAttribute('download', fileName);
                linkElement.click();
                
                alert('‚úÖ –û–±–Ω–æ–≤–ª—ë–Ω–Ω–∞—è —Å—Ö–µ–º–∞ —ç–∫—Å–ø–æ—Ä—Ç–∏—Ä–æ–≤–∞–Ω–∞!');
            };
            
            const cancelEditingScheme = () => {
                if (confirm('–û—Ç–º–µ–Ω–∏—Ç—å —Ä–µ–¥–∞–∫—Ç–∏—Ä–æ–≤–∞–Ω–∏–µ? –ù–µ—Å–æ—Ö—Ä–∞–Ω—ë–Ω–Ω—ã–µ –∏–∑–º–µ–Ω–µ–Ω–∏—è –±—É–¥—É—Ç –ø–æ—Ç–µ—Ä—è–Ω—ã.')) {
                    setEditingScheme(null);
                    setNewSchemeName('');
                    setNewSchemeEmoji('üß∏');
                    setNewSchemeDifficulty('–°—Ä–µ–¥–Ω–∏–π');
                    setSchemeParts([]);
                    setSchemeMode('scheme-details');
                }
            };
            
            const savePartPattern = () => {
                if (rows.length === 0) {
                    alert('–î–æ–±–∞–≤—å—Ç–µ —Ö–æ—Ç—è –±—ã –æ–¥–∏–Ω —Ä—è–¥');
                    return;
                }
                
                const newPart = {
                    partName: currentPartName,
                    quantity: currentPartQuantity,
                    rows: rows
                };
                
                if (editingPartIndex !== null) {
                    const updatedParts = [...schemeParts];
                    updatedParts[editingPartIndex] = newPart;
                    setSchemeParts(updatedParts);
                    setEditingPartIndex(null);
                } else {
                    setSchemeParts([...schemeParts, newPart]);
                }
                
                setRows([]);
                setCurrentRowPattern([]);
                setCurrentPartName('');
                setCurrentPartQuantity(1);
                setCurrentRowNumber(1);
                setManualInitialStitches('');
                setRepeatCount(1);
                
                // Return to appropriate mode
                if (schemeMode === 'create-part-pattern') {
                    setSchemeMode('add-parts');
                } else if (editingScheme) {
                    setSchemeMode('edit-scheme');
                }
            };
            
            const startCreatingPartPattern = () => {
                if (!currentPartName.trim()) {
                    alert('–í–≤–µ–¥–∏—Ç–µ –Ω–∞–∑–≤–∞–Ω–∏–µ –¥–µ—Ç–∞–ª–∏');
                    return;
                }
                setSchemeMode('create-part-pattern');
            };
            
            const deletePart = (index) => {
                if (confirm('–£–¥–∞–ª–∏—Ç—å —ç—Ç—É –¥–µ—Ç–∞–ª—å?')) {
                    setSchemeParts(schemeParts.filter((_, i) => i !== index));
                }
            };
            
            const editPart = (index) => {
                const part = schemeParts[index];
                setCurrentPartName(part.partName);
                setCurrentPartQuantity(part.quantity);
                setRows(part.rows);
                setEditingPartIndex(index);
                setSchemeMode('create-part-pattern');
            };
            
            useEffect(() => {
                if (schemeMode === 'library' && availableSchemes.length === 0) {
                    loadSchemesList();
                }
            }, [schemeMode]);

            if (mode === 'knitting') {
                const currentRowData = rows[currentRow];
                const currentPattern = currentRowData.pattern;
                const currentElementData = currentPattern[currentElement];
                const totalStitches = getTotalStitches(currentPattern);
                const completedStitches = getCompletedStitches(history);
                const progress = Math.round((completedStitches / totalStitches) * 100);
                const nextElements = currentPattern.slice(currentElement + 1, currentElement + 4);
                
                const totalElementsInRow = currentPattern.length;
                const completedElements = history.length;
                const totalPetelsInRow = getCurrentRowStitches(currentRow);
                const remainingFromPreviousRow = totalElementsInRow - completedElements;

                return (
                    <div className="min-h-screen bg-gradient-to-br from-teal-50 via-blue-50 to-purple-50 p-3 sm:p-4">
                        <div className="max-w-2xl mx-auto pb-20">
                            <div className="bg-white rounded-3xl shadow-lg p-4 sm:p-6 mb-4 sm:mb-6">
                                <div className="flex items-center justify-between mb-3 sm:mb-4">
                                    <div className="flex-1">
                                        <h2 className="text-xl sm:text-2xl font-bold text-gray-800">–†—è–¥ {currentRowData.rowNumber} –∏–∑ {rows[rows.length - 1].rowNumber}</h2>
                                        <p className="text-sm sm:text-base text-gray-500 mt-1">–ü–µ—Ç–µ–ª—å –ø—Ä–æ–≤—è–∑–∞–Ω–æ: {completedElements} –∏–∑ {totalPetelsInRow}</p>
                                        {(currentRow > 0 || currentRowData.manualStitches) && (
                                            <p className="text-xs sm:text-sm text-gray-400">–ò–∑ —Ä—è–¥–∞ {currentRow > 0 ? rows[currentRow - 1].rowNumber : currentRowData.rowNumber - 1} –æ—Å—Ç–∞–ª–æ—Å—å: {remainingFromPreviousRow} –ø–µ—Ç–µ–ª—å</p>
                                        )}
                                    </div>
                                    <div className="text-4xl sm:text-5xl">üêù</div>
                                </div>
                                <div className="w-full bg-gray-200 rounded-full h-2.5 sm:h-3 overflow-hidden">
                                    <div className="bg-gradient-to-r from-green-400 to-teal-500 h-full rounded-full transition-all duration-300" style={{ width: `${progress}%` }}/>
                                </div>
                                <p className="text-center text-gray-600 font-semibold mt-1.5 sm:mt-2 text-sm sm:text-base">{progress}%</p>
                            </div>

                            {history.length > 0 && (
                                <div className="bg-white rounded-3xl shadow-lg p-4 sm:p-6 mb-4 sm:mb-6">
                                    <h3 className="text-base sm:text-lg font-semibold text-gray-700 mb-2 sm:mb-3">–£–∂–µ —Å–¥–µ–ª–∞–Ω–æ:</h3>
                                    <div className="flex flex-wrap gap-1.5 sm:gap-2">
                                        {history.map((elem, idx) => (
                                            <span key={idx} className="bg-green-100 text-green-700 px-2 sm:px-3 py-1 rounded-full font-medium text-xs sm:text-sm flex items-center gap-1">
                                                {elem.type}{elem.stitches > 1 && <span className="text-xs">√ó{elem.stitches}</span>}‚úì
                                            </span>
                                        ))}
                                    </div>
                                </div>
                            )}

                            <div className={(currentElementData.type === 'COLOR_CHANGE' ? 'bg-gradient-to-br from-pink-500 to-orange-500' : 'bg-gradient-to-br from-purple-500 to-pink-500') + ' rounded-3xl shadow-2xl p-6 sm:p-8 mb-4 sm:mb-6 text-center'}>
                                <p className="text-white text-base sm:text-lg font-semibold mb-2 opacity-90">–°–ï–ô–ß–ê–° –î–ï–õ–ê–ô:</p>
                                <p className="text-white text-4xl sm:text-5xl font-bold mb-2 sm:mb-4">
                                    {currentElementData.type === 'COLOR_CHANGE' 
                                        ? `üé® –°–ú–ï–ù–ò –¶–í–ï–¢ –ù–ê ${currentElementData.color.toUpperCase()}`
                                        : (currentElementData.stitches > 1 
                                            ? currentElementData.type.toUpperCase() + ' ‚Äî ' + currentElementData.stitches + ' –ø—Ä–æ–≤—è–∑–æ–≤'
                                            : currentElementData.type.toUpperCase())
                                    }
                                </p>
                                
                                <button
                                    onClick={markStitchDone}
                                    disabled={isPaused}
                                    className="w-full bg-white hover:bg-gray-100 text-purple-600 rounded-2xl py-5 sm:py-6 font-bold text-xl sm:text-2xl transition-all transform hover:scale-105 active:scale-95 disabled:opacity-50 disabled:cursor-not-allowed shadow-lg"
                                >
                                    –ì–û–¢–û–í–û
                                </button>
                            </div>

                            {nextElements.length > 0 && (
                                <div className="bg-white rounded-3xl shadow-lg p-4 sm:p-6 mb-4 sm:mb-6">
                                    <h3 className="text-base sm:text-lg font-semibold text-gray-700 mb-2 sm:mb-3 flex items-center gap-2">
                                        –ß—Ç–æ –¥–∞–ª—å—à–µ: <ChevronRight />
                                    </h3>
                                    <div className="flex gap-1.5 sm:gap-2 flex-wrap">
                                        {nextElements.map((elem, idx) => (
                                            <span key={idx} className="bg-blue-100 text-blue-700 px-3 sm:px-4 py-1.5 sm:py-2 rounded-full font-medium text-sm sm:text-base flex items-center gap-1">
                                                {elem.type}{elem.stitches > 1 && <span className="text-xs bg-blue-500 text-white px-1.5 py-0.5 rounded-full">√ó{elem.stitches}</span>}
                                            </span>
                                        ))}
                                    </div>
                                </div>
                            )}

                            <div className="bg-white rounded-3xl shadow-lg p-4 sm:p-6">
                                <div className="grid grid-cols-3 gap-2 sm:gap-4">
                                    <button onClick={undoLast} className="bg-orange-100 hover:bg-orange-200 text-orange-700 rounded-2xl py-3 sm:py-4 font-semibold transition-all transform hover:scale-105 active:scale-95 flex flex-col items-center gap-1 sm:gap-2">
                                        <RotateCcw className="w-5 h-5 sm:w-6 sm:h-6" /><span className="text-xs sm:text-sm">–û—Ç–º–µ–Ω–∏—Ç—å</span>
                                    </button>
                                    <button onClick={() => setIsPaused(!isPaused)} className={`${isPaused ? 'bg-green-100 text-green-700' : 'bg-yellow-100 text-yellow-700'} hover:opacity-80 rounded-2xl py-3 sm:py-4 font-semibold transition-all transform hover:scale-105 active:scale-95 flex flex-col items-center gap-1 sm:gap-2`}>
                                        {isPaused ? <Play className="w-5 h-5 sm:w-6 sm:h-6" /> : <Pause className="w-5 h-5 sm:w-6 sm:h-6" />}
                                        <span className="text-xs sm:text-sm">{isPaused ? '–ü—Ä–æ–¥–æ–ª–∂–∏—Ç—å' : '–ü–∞—É–∑–∞'}</span>
                                    </button>
                                    <button onClick={editCounter} className="bg-purple-100 hover:bg-purple-200 text-purple-700 rounded-2xl py-3 sm:py-4 font-semibold transition-all transform hover:scale-105 active:scale-95 flex flex-col items-center gap-1 sm:gap-2">
                                        <Edit3 className="w-5 h-5 sm:w-6 sm:h-6" /><span className="text-xs sm:text-sm">–ü—Ä–∞–≤–∏—Ç—å</span>
                                    </button>
                                </div>
                                {recognition && (
                                    <>
                                        <button onClick={toggleVoiceControl} className={`w-full mt-3 sm:mt-4 ${isListening ? 'bg-red-100 text-red-700 animate-pulse' : 'bg-blue-100 text-blue-700'} hover:opacity-80 rounded-2xl py-3 sm:py-4 font-semibold transition-all text-sm sm:text-base flex items-center justify-center gap-2`}>
                                            <Mic className="w-5 h-5" />
                                            {isListening ? 'üé§ –°–ª—É—à–∞—é... ("–≥–æ—Ç–æ–≤–æ" / "–Ω–∞–∑–∞–¥")' : '–í–∫–ª—é—á–∏—Ç—å –≥–æ–ª–æ—Å–æ–≤–æ–µ —É–ø—Ä–∞–≤–ª–µ–Ω–∏–µ'}
                                        </button>
                                        <button onClick={() => setVoiceFeedback(!voiceFeedback)} className={`w-full mt-2 ${voiceFeedback ? 'bg-green-100 text-green-700' : 'bg-gray-100 text-gray-600'} hover:opacity-80 rounded-2xl py-3 sm:py-4 font-semibold transition-all text-sm sm:text-base flex items-center justify-center gap-2`}>
                                            {voiceFeedback ? <Volume2 className="w-5 h-5" /> : <VolumeX className="w-5 h-5" />}
                                            {voiceFeedback ? 'üîä –û–∑–≤—É—á–∫–∞ –≤–∫–ª—é—á–µ–Ω–∞' : '–í–∫–ª—é—á–∏—Ç—å –æ–∑–≤—É—á–∫—É'}
                                        </button>
                                    </>
                                )}
                                <button onClick={() => { if (confirm('–í–µ—Ä–Ω—É—Ç—å—Å—è –∫ –Ω–∞—Å—Ç—Ä–æ–π–∫–µ? –ü—Ä–æ–≥—Ä–µ—Å—Å –±—É–¥–µ—Ç –ø–æ—Ç–µ—Ä—è–Ω.')) { setMode('setup'); setCurrentRow(0); setCurrentElement(0); setHistory([]); }}} className="w-full mt-3 sm:mt-4 bg-gray-100 hover:bg-gray-200 text-gray-700 rounded-2xl py-3 sm:py-4 font-semibold transition-all text-sm sm:text-base">
                                    ‚Üê –í–µ—Ä–Ω—É—Ç—å—Å—è –∫ –Ω–∞—Å—Ç—Ä–æ–π–∫–µ
                                </button>
                            </div>
                        </div>
                    </div>
                );
            }

            return (
                <div className="min-h-screen bg-gradient-to-br from-blue-50 via-purple-50 to-pink-50 p-3 sm:p-4">
                    <div className="max-w-2xl mx-auto pb-20">
                        <div className="bg-white rounded-3xl shadow-lg p-4 sm:p-6 mb-4 sm:mb-6">
                            <div className="flex items-center justify-between">
                                <div>
                                    <h1 className="text-2xl sm:text-3xl font-bold text-gray-800">–°—á—ë—Ç—á–∏–∫ –≤—è–∑–∞–Ω–∏—è</h1>
                                    <p className="text-sm sm:text-base text-gray-500 mt-1">–°–æ–∑–¥–∞–π —Å–≤–æ–π –ø–∞—Ç—Ç–µ—Ä–Ω</p>
                                </div>
                                <div className="text-4xl sm:text-6xl">üß∂</div>
                            </div>
                        </div>

                        {schemeMode === 'library' && (
                            <div className="bg-white rounded-3xl shadow-lg p-4 sm:p-6 mb-4 sm:mb-6">
                                <div className="flex items-center justify-between mb-4">
                                    <h2 className="text-xl font-bold text-gray-800">üìö –ë–∏–±–ª–∏–æ—Ç–µ–∫–∞ —Å—Ö–µ–º</h2>
                                    <button onClick={returnToMainScreen} className="text-gray-500 hover:text-gray-700 text-sm">‚Üê –ù–∞–∑–∞–¥</button>
                                </div>
                                
                                <button onClick={importSchemeFromFile} className="w-full mb-4 bg-gradient-to-r from-blue-100 to-teal-100 hover:from-blue-200 hover:to-teal-200 text-teal-700 rounded-2xl py-3 font-semibold text-base">
                                    üì• –ò–º–ø–æ—Ä—Ç–∏—Ä–æ–≤–∞—Ç—å —Å—Ö–µ–º—É –∏–∑ —Ñ–∞–π–ª–∞
                                </button>
                                
                                {availableSchemes.length === 0 ? (
                                    <p className="text-center text-gray-500 py-8">–ó–∞–≥—Ä—É–∑–∫–∞ —Å—Ö–µ–º...</p>
                                ) : (
                                    <div className="space-y-3">
                                        {availableSchemes.map((scheme) => (
                                            <div key={scheme.id} className="bg-gradient-to-r from-pink-50 to-purple-50 rounded-2xl p-4">
                                                <div className="flex items-start justify-between">
                                                    <div className="flex-1">
                                                        <div className="flex items-center gap-2 mb-2">
                                                            <span className="text-3xl">{scheme.emoji}</span>
                                                            <h3 className="text-lg font-bold text-gray-800">{scheme.name}</h3>
                                                            {scheme.isLocal && <span className="bg-blue-100 text-blue-700 text-xs px-2 py-1 rounded-full">–õ–æ–∫–∞–ª—å–Ω–∞—è</span>}
                                                        </div>
                                                        <p className="text-sm text-gray-600">–°–ª–æ–∂–Ω–æ—Å—Ç—å: {scheme.difficulty}</p>
                                                        <p className="text-sm text-gray-600">{scheme.totalParts} –¥–µ—Ç–∞–ª–µ–π ‚Ä¢ {scheme.totalRows} —Ä—è–¥–æ–≤</p>
                                                    </div>
                                                    <button onClick={() => loadScheme(scheme.id)} className="bg-purple-500 hover:bg-purple-600 text-white rounded-xl px-4 py-2 font-semibold text-sm">
                                                        –ó–∞–≥—Ä—É–∑–∏—Ç—å
                                                    </button>
                                                </div>
                                            </div>
                                        ))}
                                    </div>
                                )}
                            </div>
                        )}

                        {schemeMode === 'scheme-details' && currentScheme && (
                            <div className="bg-white rounded-3xl shadow-lg p-4 sm:p-6 mb-4 sm:mb-6">
                                <div className="flex items-center justify-between mb-4">
                                    <div className="flex items-center gap-3">
                                        <span className="text-4xl">{currentScheme.emoji}</span>
                                        <div>
                                            <h2 className="text-xl font-bold text-gray-800">{currentScheme.name}</h2>
                                            <p className="text-sm text-gray-500">–°–ª–æ–∂–Ω–æ—Å—Ç—å: {currentScheme.difficulty}</p>
                                        </div>
                                    </div>
                                    <div className="flex gap-2">
                                        {currentScheme.isLocal && (
                                            <>
                                                <button onClick={startEditingScheme} className="text-blue-500 hover:text-blue-700 text-xl" title="–†–µ–¥–∞–∫—Ç–∏—Ä–æ–≤–∞—Ç—å">‚úèÔ∏è</button>
                                                <button onClick={() => deleteLocalScheme(currentScheme.id)} className="text-red-500 hover:text-red-700 text-xl" title="–£–¥–∞–ª–∏—Ç—å">üóëÔ∏è</button>
                                            </>
                                        )}
                                        <button onClick={() => { setSchemeMode('library'); setCurrentScheme(null); }} className="text-gray-500 hover:text-gray-700 text-sm">‚Üê –ù–∞–∑–∞–¥</button>
                                    </div>
                                </div>
                                <div className="mb-4 bg-gradient-to-r from-blue-100 to-purple-100 rounded-2xl p-3">
                                    <div className="flex items-center justify-between mb-1">
                                        <div className="text-sm font-semibold text-gray-700">–ü—Ä–æ–≥—Ä–µ—Å—Å</div>
                                        {Object.keys(schemeProgress).length > 0 && (
                                            <button onClick={resetAllProgress} className="text-xs text-blue-600 hover:text-blue-800">üîÑ –°–±—Ä–æ—Å–∏—Ç—å –≤–µ—Å—å –ø—Ä–æ–≥—Ä–µ—Å—Å</button>
                                        )}
                                    </div>
                                    <div className="flex items-center gap-2">
                                        <div className="flex-1 bg-gray-200 rounded-full h-3">
                                            <div className="bg-gradient-to-r from-green-500 to-teal-500 h-3 rounded-full" style={{width: ((Object.keys(schemeProgress).length / currentScheme.parts.reduce((sum, p) => sum + p.quantity, 0)) * 100) + '%'}}></div>
                                        </div>
                                        <span className="text-sm font-bold text-gray-700">{Object.keys(schemeProgress).length} / {currentScheme.parts.reduce((sum, p) => sum + p.quantity, 0)}</span>
                                    </div>
                                </div>
                                <h3 className="text-lg font-semibold text-gray-700 mb-3">–î–µ—Ç–∞–ª–∏:</h3>
                                <div className="space-y-3">
                                    {currentScheme.parts.map((part, partIndex) => (
                                        <div key={partIndex} className="bg-gradient-to-r from-blue-50 to-purple-50 rounded-2xl p-4">
                                            <div className="mb-2">
                                                <h4 className="font-bold text-gray-800">{part.partName} √ó {part.quantity}</h4>
                                                <p className="text-sm text-gray-600">{part.rows.length} —Ä—è–¥–æ–≤</p>
                                            </div>
                                            {part.quantity === 1 ? (
                                                <div className="flex gap-2 mt-2">
                                                    <button onClick={() => startKnittingPart(partIndex, 0)} disabled={schemeProgress[partIndex + '_0']} className={'flex-1 ' + (schemeProgress[partIndex + '_0'] ? 'bg-green-100 text-green-700' : 'bg-purple-500 hover:bg-purple-600 text-white') + ' rounded-xl py-2 font-semibold text-sm'}>
                                                        {schemeProgress[partIndex + '_0'] ? '‚úÖ –ì–æ—Ç–æ–≤–æ' : '–ù–∞—á–∞—Ç—å –≤—è–∑–∞—Ç—å'}
                                                    </button>
                                                    {schemeProgress[partIndex + '_0'] && (
                                                        <button onClick={() => resetPartProgress(partIndex, 0)} className="bg-orange-100 hover:bg-orange-200 text-orange-700 rounded-xl px-3 py-2 text-xs">üîÑ</button>
                                                    )}
                                                </div>
                                            ) : (
                                                <div className="mt-2 space-y-2">
                                                    {Array.from({length: part.quantity}).map((_, instanceIndex) => (
                                                        <div key={instanceIndex} className="flex gap-2">
                                                            <button onClick={() => startKnittingPart(partIndex, instanceIndex)} disabled={schemeProgress[partIndex + '_' + instanceIndex]} className={'flex-1 ' + (schemeProgress[partIndex + '_' + instanceIndex] ? 'bg-green-100 text-green-700' : 'bg-purple-500 hover:bg-purple-600 text-white') + ' rounded-xl py-2 font-semibold text-sm'}>
                                                                {schemeProgress[partIndex + '_' + instanceIndex] ? '‚úÖ ' + part.partName + ' ' + (instanceIndex + 1) : part.partName + ' ' + (instanceIndex + 1)}
                                                            </button>
                                                            {schemeProgress[partIndex + '_' + instanceIndex] && (
                                                                <button onClick={() => resetPartProgress(partIndex, instanceIndex)} className="bg-orange-100 hover:bg-orange-200 text-orange-700 rounded-xl px-3 py-2 text-xs">üîÑ</button>
                                                            )}
                                                        </div>
                                                    ))}
                                                </div>
                                            )}
                                        </div>
                                    ))}
                                </div>
                            </div>
                        )}

                        {schemeMode === 'create-scheme' && (
                            <div className="bg-white rounded-3xl shadow-lg p-4 sm:p-6 mb-4 sm:mb-6">
                                <div className="flex items-center justify-between mb-4">
                                    <h2 className="text-xl font-bold text-gray-800">üìù –ù–æ–≤–∞—è —Å—Ö–µ–º–∞</h2>
                                    <button onClick={returnToMainScreen} className="text-gray-500 hover:text-gray-700 text-sm">‚Üê –ù–∞–∑–∞–¥</button>
                                </div>
                                <div className="space-y-4">
                                    <div>
                                        <label className="block text-sm font-semibold text-gray-700 mb-2">–ù–∞–∑–≤–∞–Ω–∏–µ</label>
                                        <input type="text" value={newSchemeName} onChange={(e) => setNewSchemeName(e.target.value)} placeholder="–ù–∞–ø—Ä–∏–º–µ—Ä: –ú–∏—à–∫–∞ –¢–µ–¥–¥–∏" className="w-full px-4 py-3 border-2 border-gray-200 rounded-2xl focus:border-purple-400 focus:outline-none"/>
                                    </div>
                                    <div>
                                        <label className="block text-sm font-semibold text-gray-700 mb-2">–≠–º–æ–¥–∑–∏</label>
                                        <input type="text" value={newSchemeEmoji} onChange={(e) => setNewSchemeEmoji(e.target.value)} placeholder="üß∏" className="w-full px-4 py-3 border-2 border-gray-200 rounded-2xl focus:border-purple-400 focus:outline-none text-3xl text-center" maxLength={2}/>
                                    </div>
                                    <div>
                                        <label className="block text-sm font-semibold text-gray-700 mb-2">–°–ª–æ–∂–Ω–æ—Å—Ç—å</label>
                                        <select value={newSchemeDifficulty} onChange={(e) => setNewSchemeDifficulty(e.target.value)} className="w-full px-4 py-3 border-2 border-gray-200 rounded-2xl focus:border-purple-400 focus:outline-none">
                                            <option>–õ–µ–≥–∫–∏–π</option>
                                            <option>–°—Ä–µ–¥–Ω–∏–π</option>
                                            <option>–°–ª–æ–∂–Ω—ã–π</option>
                                        </select>
                                    </div>
                                    <button onClick={() => { if (!newSchemeName.trim()) { alert('–í–≤–µ–¥–∏—Ç–µ –Ω–∞–∑–≤–∞–Ω–∏–µ —Å—Ö–µ–º—ã'); return; } setSchemeMode('add-parts'); }} className="w-full bg-gradient-to-r from-purple-500 to-pink-500 hover:from-purple-600 hover:to-pink-600 text-white rounded-2xl py-3 font-bold">–î–∞–ª–µ–µ ‚Üí</button>
                                </div>
                            </div>
                        )}

                        {schemeMode === 'add-parts' && (
                            <div className="bg-white rounded-3xl shadow-lg p-4 sm:p-6 mb-4 sm:mb-6">
                                <div className="flex items-center justify-between mb-4">
                                    <h2 className="text-xl font-bold text-gray-800">üß© –î–µ—Ç–∞–ª–∏ —Å—Ö–µ–º—ã</h2>
                                    <button onClick={() => setSchemeMode('create-scheme')} className="text-gray-500 hover:text-gray-700 text-sm">‚Üê –ù–∞–∑–∞–¥</button>
                                </div>
                                {schemeParts.length > 0 && (
                                    <div className="mb-4 space-y-2">
                                        <h3 className="text-sm font-semibold text-gray-700">–î–æ–±–∞–≤–ª–µ–Ω–Ω—ã–µ –¥–µ—Ç–∞–ª–∏ ({schemeParts.length}):</h3>
                                        {schemeParts.map((part, idx) => (
                                            <div key={idx} className="bg-gradient-to-r from-blue-50 to-purple-50 rounded-xl p-3 flex items-center justify-between">
                                                <div>
                                                    <span className="font-semibold text-gray-800">{part.partName} √ó {part.quantity}</span>
                                                    <span className="text-sm text-gray-600 ml-2">({part.rows.length} —Ä—è–¥–æ–≤)</span>
                                                </div>
                                                <div className="flex gap-2">
                                                    <button onClick={() => editPart(idx)} className="text-blue-600 hover:text-blue-800 text-xl">‚úèÔ∏è</button>
                                                    <button onClick={() => deletePart(idx)} className="text-red-600 hover:text-red-800 text-xl">üóëÔ∏è</button>
                                                </div>
                                            </div>
                                        ))}
                                    </div>
                                )}
                                <div className="bg-gray-50 rounded-2xl p-4 mb-4">
                                    <h3 className="text-sm font-semibold text-gray-700 mb-3">‚ûï –î–æ–±–∞–≤–∏—Ç—å –¥–µ—Ç–∞–ª—å:</h3>
                                    <div className="space-y-3">
                                        <input type="text" value={currentPartName} onChange={(e) => setCurrentPartName(e.target.value)} placeholder="–ù–∞–∑–≤–∞–Ω–∏–µ (–Ω–∞–ø—Ä–∏–º–µ—Ä: –õ–∞–ø–∞, –ì–æ–ª–æ–≤–∞)" className="w-full px-4 py-2 border-2 border-gray-200 rounded-xl focus:border-purple-400 focus:outline-none"/>
                                        <div className="flex items-center gap-3">
                                            <span className="text-sm font-medium text-gray-700 w-28">–ö–æ–ª–∏—á–µ—Å—Ç–≤–æ:</span>
                                            <button onClick={() => setCurrentPartQuantity(Math.max(1, currentPartQuantity - 1))} className="bg-gray-200 hover:bg-gray-300 rounded-full p-1.5"><Minus className="w-4 h-4" /></button>
                                            <span className="text-xl font-bold text-purple-600 w-10 text-center">{currentPartQuantity}</span>
                                            <button onClick={() => setCurrentPartQuantity(currentPartQuantity + 1)} className="bg-gray-200 hover:bg-gray-300 rounded-full p-1.5"><Plus className="w-4 h-4" /></button>
                                        </div>
                                        <button onClick={startCreatingPartPattern} className="w-full bg-purple-500 hover:bg-purple-600 text-white rounded-xl py-2 font-semibold">–°–æ–∑–¥–∞—Ç—å –ø–∞—Ç—Ç–µ—Ä–Ω –¥–ª—è –¥–µ—Ç–∞–ª–∏</button>
                                    </div>
                                </div>
                                {schemeParts.length > 0 && (
                                    <div className="space-y-2">
                                        <button onClick={saveSchemeLocally} className="w-full bg-gradient-to-r from-purple-500 to-pink-500 hover:from-purple-600 hover:to-pink-600 text-white rounded-2xl py-3 font-bold">üíæ –°–æ—Ö—Ä–∞–Ω–∏—Ç—å –≤ –±—Ä–∞—É–∑–µ—Ä–µ</button>
                                        <button onClick={exportSchemeToJSON} className="w-full bg-gradient-to-r from-blue-500 to-teal-500 hover:from-blue-600 hover:to-teal-600 text-white rounded-2xl py-3 font-bold">üì• –°–æ—Ö—Ä–∞–Ω–∏—Ç—å –Ω–∞ —É—Å—Ç—Ä–æ–π—Å—Ç–≤–æ</button>
                                    </div>
                                )}
                            </div>
                        )}

                        {schemeMode === 'edit-scheme' && editingScheme && (
                            <div className="bg-white rounded-3xl shadow-lg p-4 sm:p-6 mb-4 sm:mb-6">
                                <div className="flex items-center justify-between mb-4">
                                    <h2 className="text-xl font-bold text-gray-800">‚úèÔ∏è –†–µ–¥–∞–∫—Ç–∏—Ä–æ–≤–∞–Ω–∏–µ —Å—Ö–µ–º—ã</h2>
                                    <button onClick={cancelEditingScheme} className="text-gray-500 hover:text-gray-700 text-sm">‚ùå –û—Ç–º–µ–Ω–∞</button>
                                </div>
                                
                                <div className="space-y-4 mb-4">
                                    <div>
                                        <label className="block text-sm font-semibold text-gray-700 mb-2">–ù–∞–∑–≤–∞–Ω–∏–µ</label>
                                        <input type="text" value={newSchemeName} onChange={(e) => setNewSchemeName(e.target.value)} className="w-full px-4 py-3 border-2 border-gray-200 rounded-2xl focus:border-purple-400 focus:outline-none"/>
                                    </div>
                                    <div>
                                        <label className="block text-sm font-semibold text-gray-700 mb-2">–≠–º–æ–¥–∑–∏</label>
                                        <input type="text" value={newSchemeEmoji} onChange={(e) => setNewSchemeEmoji(e.target.value)} className="w-full px-4 py-3 border-2 border-gray-200 rounded-2xl focus:border-purple-400 focus:outline-none text-3xl text-center" maxLength={2}/>
                                    </div>
                                    <div>
                                        <label className="block text-sm font-semibold text-gray-700 mb-2">–°–ª–æ–∂–Ω–æ—Å—Ç—å</label>
                                        <select value={newSchemeDifficulty} onChange={(e) => setNewSchemeDifficulty(e.target.value)} className="w-full px-4 py-3 border-2 border-gray-200 rounded-2xl focus:border-purple-400 focus:outline-none">
                                            <option>–õ–µ–≥–∫–∏–π</option>
                                            <option>–°—Ä–µ–¥–Ω–∏–π</option>
                                            <option>–°–ª–æ–∂–Ω—ã–π</option>
                                        </select>
                                    </div>
                                </div>

                                {schemeParts.length > 0 && (
                                    <div className="mb-4">
                                        <h3 className="text-sm font-semibold text-gray-700 mb-2">–î–µ—Ç–∞–ª–∏ ({schemeParts.length}):</h3>
                                        <div className="space-y-2">
                                            {schemeParts.map((part, idx) => (
                                                <div key={idx} className="bg-gradient-to-r from-blue-50 to-purple-50 rounded-xl p-3 flex items-center justify-between">
                                                    <div>
                                                        <span className="font-semibold text-gray-800">{part.partName} √ó {part.quantity}</span>
                                                        <span className="text-sm text-gray-600 ml-2">({part.rows.length} —Ä—è–¥–æ–≤)</span>
                                                    </div>
                                                    <div className="flex gap-2">
                                                        <button onClick={() => editPart(idx)} className="text-blue-600 hover:text-blue-800 text-xl">‚úèÔ∏è</button>
                                                        <button onClick={() => deletePart(idx)} className="text-red-600 hover:text-red-800 text-xl">üóëÔ∏è</button>
                                                    </div>
                                                </div>
                                            ))}
                                        </div>
                                    </div>
                                )}

                                <div className="bg-gray-50 rounded-2xl p-4 mb-4">
                                    <h3 className="text-sm font-semibold text-gray-700 mb-3">‚ûï –î–æ–±–∞–≤–∏—Ç—å –¥–µ—Ç–∞–ª—å:</h3>
                                    <div className="space-y-3">
                                        <input type="text" value={currentPartName} onChange={(e) => setCurrentPartName(e.target.value)} placeholder="–ù–∞–∑–≤–∞–Ω–∏–µ –¥–µ—Ç–∞–ª–∏" className="w-full px-4 py-2 border-2 border-gray-200 rounded-xl focus:border-purple-400 focus:outline-none"/>
                                        <div className="flex items-center gap-3">
                                            <span className="text-sm font-medium text-gray-700 w-28">–ö–æ–ª–∏—á–µ—Å—Ç–≤–æ:</span>
                                            <button onClick={() => setCurrentPartQuantity(Math.max(1, currentPartQuantity - 1))} className="bg-gray-200 hover:bg-gray-300 rounded-full p-1.5"><Minus className="w-4 h-4" /></button>
                                            <span className="text-xl font-bold text-purple-600 w-10 text-center">{currentPartQuantity}</span>
                                            <button onClick={() => setCurrentPartQuantity(currentPartQuantity + 1)} className="bg-gray-200 hover:bg-gray-300 rounded-full p-1.5"><Plus className="w-4 h-4" /></button>
                                        </div>
                                        <button onClick={startCreatingPartPattern} className="w-full bg-purple-500 hover:bg-purple-600 text-white rounded-xl py-2 font-semibold">–°–æ–∑–¥–∞—Ç—å –ø–∞—Ç—Ç–µ—Ä–Ω</button>
                                    </div>
                                </div>

                                <div className="space-y-2">
                                    <button onClick={saveEditedScheme} className="w-full bg-gradient-to-r from-green-500 to-teal-500 hover:from-green-600 hover:to-teal-600 text-white rounded-2xl py-3 font-bold">üíæ –°–æ—Ö—Ä–∞–Ω–∏—Ç—å –∏–∑–º–µ–Ω–µ–Ω–∏—è</button>
                                    <button onClick={exportEditedScheme} className="w-full bg-gradient-to-r from-blue-500 to-purple-500 hover:from-blue-600 hover:to-purple-600 text-white rounded-2xl py-3 font-bold">üì• –≠–∫—Å–ø–æ—Ä—Ç–∏—Ä–æ–≤–∞—Ç—å —Å—Ö–µ–º—É</button>
                                </div>
                            </div>
                        )}

                        {(schemeMode === 'main' || schemeMode === 'create-part-pattern' || (schemeMode === 'edit-scheme' && currentPartName)) && (
                            <>
                                {schemeMode === 'create-part-pattern' && (
                                    <div className="bg-white rounded-3xl shadow-lg p-4 sm:p-6 mb-4 sm:mb-6">
                                        <div className="flex items-center justify-between mb-4">
                                            <div>
                                                <h2 className="text-xl font-bold text-gray-800">–ü–∞—Ç—Ç–µ—Ä–Ω: {currentPartName}</h2>
                                                <p className="text-sm text-gray-500">–ë—É–¥–µ—Ç {currentPartQuantity} —à—Ç</p>
                                            </div>
                                            <button onClick={() => { if (confirm('–û—Ç–º–µ–Ω–∏—Ç—å —Å–æ–∑–¥–∞–Ω–∏–µ –ø–∞—Ç—Ç–µ—Ä–Ω–∞?')) { setRows([]); setCurrentRowPattern([]); setSchemeMode('add-parts'); }}} className="text-gray-500 hover:text-gray-700 text-xl">‚ùå</button>
                                        </div>
                                        {rows.length > 0 && (
                                            <button onClick={savePartPattern} className="w-full mb-4 bg-gradient-to-r from-green-500 to-teal-500 hover:from-green-600 hover:to-teal-600 text-white rounded-2xl py-3 font-bold">‚úÖ –°–æ—Ö—Ä–∞–Ω–∏—Ç—å –¥–µ—Ç–∞–ª—å</button>
                                        )}
                                    </div>
                                )}
                                
                                {schemeMode === 'edit-scheme' && currentPartName && (
                                    <div className="bg-white rounded-3xl shadow-lg p-4 sm:p-6 mb-4 sm:mb-6">
                                        <div className="flex items-center justify-between mb-4">
                                            <div>
                                                <h2 className="text-xl font-bold text-gray-800">–†–µ–¥–∞–∫—Ç–∏—Ä–æ–≤–∞–Ω–∏–µ: {currentPartName}</h2>
                                                <p className="text-sm text-gray-500">–ë—É–¥–µ—Ç {currentPartQuantity} —à—Ç</p>
                                            </div>
                                            <button onClick={() => { if (confirm('–û—Ç–º–µ–Ω–∏—Ç—å?')) { setRows([]); setCurrentRowPattern([]); setCurrentPartName(''); setEditingPartIndex(null); }}} className="text-gray-500 hover:text-gray-700 text-xl">‚ùå</button>
                                        </div>
                                        {rows.length > 0 && (
                                            <button onClick={savePartPattern} className="w-full mb-4 bg-gradient-to-r from-green-500 to-teal-500 hover:from-green-600 hover:to-teal-600 text-white rounded-2xl py-3 font-bold">‚úÖ –°–æ—Ö—Ä–∞–Ω–∏—Ç—å –¥–µ—Ç–∞–ª—å</button>
                                        )}
                                    </div>
                                )}
                                
                                {schemeMode === 'main' && (
                                    <div className="bg-white rounded-3xl shadow-lg p-4 sm:p-6 mb-4 sm:mb-6">
                                        <h2 className="text-base sm:text-lg font-semibold text-gray-700 mb-3">üìö –°—Ö–µ–º—ã –∂–∏–≤–æ—Ç–Ω—ã—Ö</h2>
                                        <div className="space-y-2">
                                            <button onClick={() => setSchemeMode('library')} className="w-full bg-gradient-to-r from-pink-100 to-purple-100 hover:from-pink-200 hover:to-purple-200 text-purple-700 rounded-2xl py-3 font-semibold text-base">–û—Ç–∫—Ä—ã—Ç—å –±–∏–±–ª–∏–æ—Ç–µ–∫—É —Å—Ö–µ–º</button>
                                            <button onClick={startSchemeCreation} className="w-full bg-gradient-to-r from-blue-100 to-teal-100 hover:from-blue-200 hover:to-teal-200 text-teal-700 rounded-2xl py-3 font-semibold text-base">–°–æ–∑–¥–∞—Ç—å –Ω–æ–≤—É—é —Å—Ö–µ–º—É</button>
                                        </div>
                                    </div>
                                )}
                                
                                <div className="bg-white rounded-3xl shadow-lg p-4 sm:p-6 mb-4 sm:mb-6">
                                    <h2 className="text-base sm:text-lg font-semibold text-gray-700 mb-3 sm:mb-4">{schemeMode === 'main' ? '–ò–ª–∏ —Å–æ–∑–¥–∞–π –ø—Ä–æ—Å—Ç–æ–π –ø–∞—Ç—Ç–µ—Ä–Ω - ' : ''}–ë—ã—Å—Ç—Ä—ã–µ —ç–ª–µ–º–µ–Ω—Ç—ã</h2>
                            <div className="grid grid-cols-3 gap-2 sm:gap-3 mb-3 sm:mb-4">
                                {quickButtons.map((btn) => (
                                    <button key={btn.value} onClick={() => addToPattern(btn.value)} className={(btn.color) + ' rounded-2xl py-3 sm:py-4 px-3 sm:px-4 font-semibold text-base sm:text-lg transition-all transform hover:scale-105 active:scale-95'}>{btn.label}</button>
                                ))}
                            </div>
                            <div className="grid grid-cols-2 gap-2 sm:gap-3">
                                <button onClick={addIncrease} className="bg-green-100 hover:bg-green-200 text-green-700 rounded-2xl py-3 sm:py-4 px-3 sm:px-4 font-semibold text-base sm:text-lg transition-all transform hover:scale-105 active:scale-95">–ü—Ä–∏–±–∞–≤–∫–∞</button>
                                <button onClick={addDecrease} className="bg-red-100 hover:bg-red-200 text-red-700 rounded-2xl py-3 sm:py-4 px-3 sm:px-4 font-semibold text-base sm:text-lg transition-all transform hover:scale-105 active:scale-95">–£–±–∞–≤–∫–∞</button>
                            </div>
                        </div>

                        <div className="bg-white rounded-3xl shadow-lg p-4 sm:p-6 mb-4 sm:mb-6">
                            <h2 className="text-base sm:text-lg font-semibold text-gray-700 mb-3 sm:mb-4">–ò–ª–∏ –≤–≤–µ–¥–∏ —Å–≤–æ–π —ç–ª–µ–º–µ–Ω—Ç</h2>
                            <div className="flex gap-2 sm:gap-3 mb-3">
                                <input type="text" value={customInput} onChange={(e) => setCustomInput(e.target.value)} onKeyPress={(e) => e.key === 'Enter' && addCustomElement()} placeholder="–ù–∞–ø—Ä–∏–º–µ—Ä: –ø–∏–∫–æ, —à–∏—à–µ—á–∫–∞, –ø—Å—Å–Ω..." className="flex-1 px-3 sm:px-4 py-2 sm:py-3 border-2 border-gray-200 rounded-2xl focus:border-purple-400 focus:outline-none text-base"/>
                                <button onClick={addCustomElement} className="bg-purple-500 hover:bg-purple-600 text-white rounded-2xl px-5 sm:px-6 font-semibold text-lg transition-all transform hover:scale-105 active:scale-95 flex-shrink-0">+</button>
                            </div>
                            <div className="space-y-3">
                                <div className="flex items-center gap-3">
                                    <span className="text-sm sm:text-base text-gray-700 font-medium w-24">–ü—Ä–æ–≤—è–∑–æ–≤:</span>
                                    <button onClick={() => setCustomStitches(Math.max(1, customStitches - 1))} className="bg-gray-200 hover:bg-gray-300 rounded-full p-1.5 transition-colors">
                                        <Minus className="w-4 h-4" />
                                    </button>
                                    <span className="text-lg sm:text-xl font-bold text-purple-600 w-8 text-center">{customStitches}</span>
                                    <button onClick={() => setCustomStitches(customStitches + 1)} className="bg-gray-200 hover:bg-gray-300 rounded-full p-1.5 transition-colors">
                                        <Plus className="w-4 h-4" />
                                    </button>
                                </div>
                                <div className="flex items-center gap-3">
                                    <span className="text-sm sm:text-base text-gray-700 font-medium w-24">–ë–∞–ª–∞–Ω—Å:</span>
                                    <div className="flex gap-1">
                                        {[-2, -1, 0, 1, 2].map(val => (
                                            <button key={val} onClick={() => setCustomBalance(val)} className={(customBalance === val ? 'bg-purple-500 text-white' : 'bg-gray-200 text-gray-700') + ' hover:opacity-80 rounded-lg px-2 sm:px-3 py-1 font-semibold text-sm transition-all'}>
                                                {val > 0 ? '+' + val : val}
                                            </button>
                                        ))}
                                    </div>
                                </div>
                            </div>
                        </div>
                        
                        <div className="bg-white rounded-3xl shadow-lg p-4 sm:p-6 mb-4 sm:mb-6">
                            <h2 className="text-base sm:text-lg font-semibold text-gray-700 mb-3 sm:mb-4">üé® –°–º–µ–Ω–∞ —Ü–≤–µ—Ç–∞</h2>
                            <div className="flex gap-2 sm:gap-3">
                                <input type="text" value={colorInput} onChange={(e) => setColorInput(e.target.value)} onKeyPress={(e) => e.key === 'Enter' && addColorChange()} placeholder="–ù–∞–ø—Ä–∏–º–µ—Ä: –±–µ–ª—ã–π, –±–µ–∂–µ–≤—ã–π, –∫—Ä–∞—Å–Ω—ã–π..." className="flex-1 px-3 sm:px-4 py-2 sm:py-3 border-2 border-gray-200 rounded-2xl focus:border-purple-400 focus:outline-none text-base"/>
                                <button onClick={addColorChange} className="bg-gradient-to-r from-pink-500 to-orange-500 hover:from-pink-600 hover:to-orange-600 text-white rounded-2xl px-5 sm:px-6 font-semibold text-lg transition-all transform hover:scale-105 active:scale-95 flex-shrink-0">üé®</button>
                            </div>
                        </div>

                        {currentRowPattern.length > 0 && (
                            <div className="bg-white rounded-3xl shadow-lg p-4 sm:p-6 mb-4 sm:mb-6">
                                <div className="flex items-center justify-between mb-3 sm:mb-4">
                                    <h2 className="text-base sm:text-lg font-semibold text-gray-700">–¢–µ–∫—É—â–∏–π –ø–∞—Ç—Ç–µ—Ä–Ω</h2>
                                    <button onClick={removeLastFromPattern} className="text-red-500 hover:text-red-700 transition-colors"><Minus /></button>
                                </div>
                                <div className="flex flex-wrap gap-2 mb-3 sm:mb-4">
                                    {currentRowPattern.map((elem, idx) => (
                                        elem.type === 'COLOR_CHANGE' ? (
                                            <span key={idx} className="bg-gradient-to-r from-pink-100 to-orange-100 text-orange-700 px-3 sm:px-4 py-1.5 sm:py-2 rounded-full font-medium text-sm sm:text-lg flex items-center gap-2">
                                                üé® ‚Üí {elem.color}
                                            </span>
                                        ) : (
                                            <span key={idx} className="bg-gradient-to-r from-purple-100 to-pink-100 text-purple-700 px-3 sm:px-4 py-1.5 sm:py-2 rounded-full font-medium text-sm sm:text-lg flex items-center gap-2">
                                                {elem.type}
                                                {elem.stitches > 1 && <span className="bg-purple-500 text-white text-xs px-1.5 sm:px-2 py-0.5 rounded-full">√ó{elem.stitches}</span>}
                                                <span className="text-purple-600 font-semibold flex items-center gap-1">
                                                    √ó
                                                    {editingElementIndex === idx ? (
                                                        <input
                                                            type="number"
                                                            value={elem.repeatCount || 1}
                                                            onChange={(e) => {
                                                                const val = e.target.value;
                                                                // –†–∞–∑—Ä–µ—à–∞–µ–º –ø—É—Å—Ç–æ–µ –ø–æ–ª–µ –≤–æ –≤—Ä–µ–º—è –≤–≤–æ–¥–∞
                                                                if (val === '') {
                                                                    const updated = [...currentRowPattern];
                                                                    updated[idx] = { ...updated[idx], repeatCount: '' };
                                                                    setCurrentRowPattern(updated);
                                                                    return;
                                                                }
                                                                const num = parseInt(val);
                                                                if (num >= 1) {
                                                                    updateElementRepeatCount(idx, num);
                                                                }
                                                            }}
                                                            onBlur={() => {
                                                                // –ü—Ä–∏ –ø–æ—Ç–µ—Ä–µ —Ñ–æ–∫—É—Å–∞ —É—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ–º –º–∏–Ω–∏–º—É–º 1
                                                                if (!currentRowPattern[idx].repeatCount || currentRowPattern[idx].repeatCount < 1) {
                                                                    updateElementRepeatCount(idx, 1);
                                                                }
                                                                setEditingElementIndex(null);
                                                            }}
                                                            onKeyPress={(e) => {
                                                                if (e.key === 'Enter') {
                                                                    if (!currentRowPattern[idx].repeatCount || currentRowPattern[idx].repeatCount < 1) {
                                                                        updateElementRepeatCount(idx, 1);
                                                                    }
                                                                    setEditingElementIndex(null);
                                                                }
                                                            }}
                                                            onFocus={(e) => e.target.select()}
                                                            autoFocus
                                                            className="w-12 text-center border-b-2 border-purple-600 bg-transparent focus:outline-none"
                                                            min="1"
                                                        />
                                                    ) : (
                                                        <span 
                                                            onClick={() => setEditingElementIndex(idx)}
                                                            className="cursor-pointer hover:underline"
                                                        >
                                                            {elem.repeatCount || 1}
                                                        </span>
                                                    )}
                                                </span>
                                            </span>
                                        )
                                    ))}
                                </div>
                                <div className="flex items-center gap-3 sm:gap-4 mb-3 sm:mb-4">
                                    <span className="text-sm sm:text-base text-gray-700 font-medium">–ü–æ–≤—Ç–æ—Ä–∏—Ç—å:</span>
                                    <button onClick={() => setRepeatCount(Math.max(1, repeatCount - 1))} className="bg-gray-200 hover:bg-gray-300 rounded-full p-1.5 sm:p-2 transition-colors"><Minus className="w-4 h-4 sm:w-5 sm:h-5" /></button>
                                    <span className="text-xl sm:text-2xl font-bold text-purple-600 w-10 sm:w-12 text-center">{repeatCount}</span>
                                    <button onClick={() => setRepeatCount(repeatCount + 1)} className="bg-gray-200 hover:bg-gray-300 rounded-full p-1.5 sm:p-2 transition-colors"><Plus className="w-4 h-4 sm:w-5 sm:h-5" /></button>
                                    <span className="text-sm sm:text-base text-gray-600">—Ä–∞–∑</span>
                                </div>
                                
                                <div className="space-y-3 mb-3 sm:mb-4">
                                    <div className="flex items-center gap-3">
                                        <span className="text-sm sm:text-base text-gray-700 font-medium w-28">–†—è–¥ ‚Ññ:</span>
                                        <button onClick={() => setCurrentRowNumber(Math.max(1, currentRowNumber - 1))} className="bg-gray-200 hover:bg-gray-300 rounded-full p-1.5 sm:p-2 transition-colors"><Minus className="w-4 h-4 sm:w-5 sm:h-5" /></button>
                                        <span className="text-xl sm:text-2xl font-bold text-purple-600 w-10 sm:w-12 text-center">{currentRowNumber}</span>
                                        <button onClick={() => setCurrentRowNumber(currentRowNumber + 1)} className="bg-gray-200 hover:bg-gray-300 rounded-full p-1.5 sm:p-2 transition-colors"><Plus className="w-4 h-4 sm:w-5 sm:h-5" /></button>
                                    </div>
                                    <div className="flex items-center gap-3">
                                        <span className="text-sm sm:text-base text-gray-700 font-medium w-28">–ü–µ—Ç–µ–ª—å –±—ã–ª–æ:</span>
                                        <input 
                                            type="number" 
                                            value={manualInitialStitches} 
                                            onChange={(e) => setManualInitialStitches(e.target.value)}
                                            placeholder="–∞–≤—Ç–æ"
                                            className="flex-1 px-3 py-2 border-2 border-gray-200 rounded-xl focus:border-purple-400 focus:outline-none text-base"
                                        />
                                    </div>
                                </div>
                                
                                <div className="bg-blue-50 rounded-2xl p-3 mb-3">
                                    <div className="text-sm text-gray-700">
                                        {currentRowPattern.length > 0 && (
                                            <div className="flex items-center gap-2 mb-1">
                                                <span>üî¢</span>
                                                <span className="font-semibold">
                                                    –ü–∞—Ç—Ç–µ—Ä–Ω —Ç—Ä–µ–±—É–µ—Ç: {currentRowPattern.reduce((sum, el) => {
                                                        if (el.isMarker) return sum;
                                                        const inputStitches = el.outputStitches - el.balance;
                                                        const elRepeat = el.repeatCount || 1;
                                                        return sum + (inputStitches * elRepeat);
                                                    }, 0) * repeatCount} –ø–µ—Ç–µ–ª—å
                                                </span>
                                            </div>
                                        )}
                                        <div className="flex items-center gap-2 mb-1">
                                            <span>üí°</span>
                                            <span className="font-semibold">
                                                {currentRowNumber === 1 ? '–ü–µ—Ä–≤—ã–π —Ä—è–¥' : 
                                                 manualInitialStitches.trim() !== '' ? `–í –ø—Ä–µ–¥—ã–¥—É—â–µ–º —Ä—è–¥—É: ${manualInitialStitches} –ø–µ—Ç–µ–ª—å` :
                                                 rows.length > 0 ? `–í –ø—Ä–µ–¥—ã–¥—É—â–µ–º —Ä—è–¥—É: ${getCurrentRowStitches(rows.length - 1)} –ø–µ—Ç–µ–ª—å` : 
                                                 `–í–≤–µ–¥–∏ —Å–∫–æ–ª—å–∫–æ –ø–µ—Ç–µ–ª—å –±—ã–ª–æ –≤ —Ä—è–¥—É ${currentRowNumber - 1}`}
                                            </span>
                                        </div>
                                        <div className="flex items-center gap-2">
                                            <span>üìä</span>
                                            <span className="font-semibold">
                                                {currentRowNumber === 1 || manualInitialStitches.trim() !== '' || rows.length > 0 ? (
                                                    `–í —ç—Ç–æ–º —Ä—è–¥—É —Å—Ç–∞–Ω–µ—Ç: ${
                                                        rows.length === 0 
                                                            ? getFirstRowOutputStitches(currentRowPattern) * repeatCount
                                                            : manualInitialStitches.trim() !== ''
                                                                ? parseInt(manualInitialStitches) + getStitchBalance(currentRowPattern) * repeatCount
                                                                : getCurrentRowStitches(rows.length - 1) + getStitchBalance(currentRowPattern) * repeatCount
                                                    } –ø–µ—Ç–µ–ª—å`
                                                ) : (
                                                    '–†–∞—Å—á—ë—Ç –ø–æ—Å–ª–µ –≤–≤–æ–¥–∞ –Ω–∞—á–∞–ª—å–Ω—ã—Ö –ø–µ—Ç–µ–ª—å'
                                                )}
                                            </span>
                                        </div>
                                    </div>
                                </div>
                                <button onClick={addRow} className="w-full bg-gradient-to-r from-purple-500 to-pink-500 hover:from-purple-600 hover:to-pink-600 text-white rounded-2xl py-3 sm:py-4 font-bold text-base sm:text-lg transition-all transform hover:scale-105 active:scale-95">–î–æ–±–∞–≤–∏—Ç—å —Ä—è–¥</button>
                            </div>
                        )}

                        {rows.length > 0 && (
                            <div className="bg-white rounded-3xl shadow-lg p-4 sm:p-6 mb-4 sm:mb-6">
                                <h2 className="text-base sm:text-lg font-semibold text-gray-700 mb-3 sm:mb-4">–†—è–¥—ã ({rows.length})</h2>
                                <div className="space-y-2 sm:space-y-3 max-h-80 sm:max-h-96 overflow-y-auto">
                                    {rows.map((row, idx) => {
                                        const previousStitches = getPreviousRowStitches(idx);
                                        const currentStitches = getCurrentRowStitches(idx);
                                        return (
                                            <div key={idx} className="bg-gradient-to-r from-blue-50 to-purple-50 rounded-2xl p-3 sm:p-4">
                                                <div className="flex items-start justify-between mb-2">
                                                    <span className="font-bold text-purple-700 text-sm sm:text-base">–†—è–¥ {row.rowNumber}:</span>
                                                    <div className="flex gap-2">
                                                        <button onClick={() => editRow(idx)} className="text-green-600 hover:text-green-800 transition-colors" title="–†–µ–¥–∞–∫—Ç–∏—Ä–æ–≤–∞—Ç—å">‚úèÔ∏è</button>
                                                        <button onClick={() => openRepeatRowDialog(idx)} className="text-blue-500 hover:text-blue-700 transition-colors" title="–ü–æ–≤—Ç–æ—Ä–∏—Ç—å —Ä—è–¥">üîÅ</button>
                                                        <button onClick={() => deleteRow(idx)} className="text-red-500 hover:text-red-700 transition-colors"><Trash2 className="w-4 h-4 sm:w-5 sm:h-5" /></button>
                                                    </div>
                                                </div>
                                                <div className="flex flex-wrap gap-1.5 sm:gap-2 text-xs sm:text-sm mb-2">
                                                    {groupConsecutiveElements(row.pattern).map((group, elemIdx) => (
                                                        <span key={elemIdx} className="text-gray-700">
                                                            {group.element.type === 'COLOR_CHANGE' ? 'üé® ‚Üí ' + group.element.color : group.element.type}
                                                            {group.count > 1 && <span className="text-purple-600 font-semibold"> √ó {group.count}</span>}
                                                            {group.element.stitches > 1 && !group.element.isMarker && <span className="text-purple-600 font-semibold"> ({group.element.stitches} –ø—Ä–æ–≤.)</span>}
                                                            {elemIdx < groupConsecutiveElements(row.pattern).length - 1 && ', '}
                                                        </span>
                                                    ))}
                                                </div>
                                                <div className="text-gray-500 text-xs sm:text-sm space-y-0.5">
                                                    {idx === 0 ? (
                                                        <p>–ü–µ—Ç–µ–ª—å –ø–æ–ª—É—á–∏—Ç—Å—è: {currentStitches}</p>
                                                    ) : (
                                                        <p>–ë—ã–ª–æ –ø–µ—Ç–µ–ª—å: {previousStitches} ‚Üí –°—Ç–∞–Ω–µ—Ç: {currentStitches}</p>
                                                    )}
                                                </div>
                                            </div>
                                        );
                                    })}
                                </div>
                                <button onClick={startKnitting} className="w-full mt-4 sm:mt-6 bg-gradient-to-r from-green-500 to-teal-500 hover:from-green-600 hover:to-teal-600 text-white rounded-2xl py-4 sm:py-5 font-bold text-lg sm:text-xl transition-all transform hover:scale-105 active:scale-95 flex items-center justify-center gap-2 sm:gap-3">
                                    <Play className="w-5 h-5 sm:w-6 sm:h-6" />–ù–∞—á–∞—Ç—å –≤—è–∑–∞—Ç—å!
                                </button>
                            </div>
                        )}
                    </>
                )}
                
                
                {/* –ú–æ–¥–∞–ª—å–Ω–æ–µ –æ–∫–Ω–æ –ø–æ–≤—Ç–æ—Ä–µ–Ω–∏—è —Ä—è–¥–∞ */}
                {repeatRowIndex !== null && (
                    <div className="fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50 p-4">
                        <div className="bg-white rounded-3xl p-6 max-w-md w-full shadow-2xl">
                            <h2 className="text-xl font-bold text-gray-800 mb-4">–ü–æ–≤—Ç–æ—Ä–∏—Ç—å —Ä—è–¥</h2>
                            <p className="text-gray-600 mb-4">–ü–∞—Ç—Ç–µ—Ä–Ω —Ä—è–¥–∞ {rows[repeatRowIndex].rowNumber}:</p>
                            <div className="flex flex-wrap gap-2 mb-4 p-3 bg-gray-50 rounded-xl">
                                {rows[repeatRowIndex].pattern.map((elem, idx) => (
                                    <span key={idx} className="text-sm text-gray-700">
                                        {elem.type === 'COLOR_CHANGE' ? 'üé® ‚Üí ' + elem.color : elem.type}
                                        {elem.stitches > 1 && ' √ó' + elem.stitches}
                                        {idx < rows[repeatRowIndex].pattern.length - 1 && ','}
                                    </span>
                                ))}
                            </div>
                            <div className="mb-6">
                                <label className="block text-sm font-semibold text-gray-700 mb-2">–ü–æ–≤—Ç–æ—Ä–∏—Ç—å —Å–∫–æ–ª—å–∫–æ —Ä–∞–∑:</label>
                                <div className="flex items-center gap-3">
                                    <button onClick={() => setRepeatRowCount(Math.max(1, repeatRowCount - 1))} className="bg-gray-200 hover:bg-gray-300 rounded-full p-2 transition-colors">
                                        <Minus className="w-5 h-5" />
                                    </button>
                                    <input 
                                        type="number" 
                                        value={repeatRowCount} 
                                        onChange={(e) => setRepeatRowCount(Math.min(20, Math.max(1, parseInt(e.target.value) || 1)))}
                                        className="text-2xl font-bold text-purple-600 w-24 text-center border-2 border-gray-200 rounded-xl px-2 py-1 focus:border-purple-400 focus:outline-none"
                                        min="1"
                                        max="20"
                                    />
                                    <button onClick={() => setRepeatRowCount(Math.min(20, repeatRowCount + 1))} className="bg-gray-200 hover:bg-gray-300 rounded-full p-2 transition-colors">
                                        <Plus className="w-5 h-5" />
                                    </button>
                                </div>
                                <p className="text-sm text-gray-500 mt-2">–°–æ–∑–¥–∞—Å—Ç —Ä—è–¥—ã: {rows.length + 1}-{rows.length + repeatRowCount}</p>
                            </div>
                            <div className="flex gap-3">
                                <button onClick={closeRepeatRowDialog} className="flex-1 bg-gray-200 hover:bg-gray-300 text-gray-700 rounded-2xl py-3 font-semibold transition-colors">–û—Ç–º–µ–Ω–∞</button>
                                <button onClick={confirmRepeatRow} className="flex-1 bg-gradient-to-r from-purple-500 to-pink-500 hover:from-purple-600 hover:to-pink-600 text-white rounded-2xl py-3 font-semibold transition-all">–°–æ–∑–¥–∞—Ç—å</button>
                            </div>
                        </div>
                    </div>
                )}
                    </div>
                </div>
            );
        };

        ReactDOM.render(<CrochetCounter />, document.getElementById('root'));
    </script>
</body>
</html>